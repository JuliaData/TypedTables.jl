var documenterSearchIndex = {"docs":
[{"location":"man/group/#Grouping-data","page":"Grouping data","title":"Grouping data","text":"","category":"section"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"It is frequently useful to break data appart into different groups for processing - a paradigm frequently referred to a the split-apply-combine methodology.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"In a powerful environment such as Julia, that fully supports nested containers, it makes sense to represent each group as distinct containers, with an outer container acting as a \"dictionary\" of the groups. This is in contrast to environments with a less rich system of containers, such as SQL, which has popularized a slightly different notion of grouping data into a single flat tabular structure, where one (or more) columns act as the grouping key. Here we focus on the former approach.","category":"page"},{"location":"man/group/#Using-the-group-function","page":"Grouping data","title":"Using the group function","text":"","category":"section"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"SplitApplyCombine provides a group function, which can operate on arbitary Julia objects. The function has the signature group(by, f, iter) where iter is a container that can be iterated, by is a function from the elements of iter to the grouping key, and the optional argument f is a mapping applied to the grouped elements (by default, f = identity, the identity function).","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"To demonstrate the power of grouping, this time we'll add some more rows and columns to our example data.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> t = Table(firstname = [\"Alice\", \"Bob\", \"Charlie\", \"Adam\", \"Eve\", \"Cindy\", \"Arthur\"], lastname = [\"Smith\", \"Smith\", \"Smith\", \"Williams\", \"Williams\", \"Brown\", \"King\"], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   ┌─────────────────────────\n 1 │ Alice      Smith     25\n 2 │ Bob        Smith     42\n 3 │ Charlie    Smith     37\n 4 │ Adam       Williams  65\n 5 │ Eve        Williams  18\n 6 │ Cindy      Brown     33\n 7 │ Arthur     King      54","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"Let's get familiar with the basic usage of group on standard (non-tabular) arrays. For example, let's group people's first name by their first letter.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> group(first, t.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' => [\"Charlie\", \"Cindy\"]\n  'A' => [\"Alice\", \"Adam\", \"Arthur\"]\n  'E' => [\"Eve\"]\n  'B' => [\"Bob\"]","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"The groups are returned as a Dict where they indices (or keys) of the dictionary are the first character of people's firstname string. The values of the Dict are arrays listing the matching firstnames.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"Next, we may want to group up data coming from a table (not just a single column). For example, we may want to group firstnames by lastname.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> group(getproperty(:lastname), getproperty(:firstname), t)\nDict{String,Array{String,1}} with 4 entries:\n  \"King\"     => [\"Arthur\"]\n  \"Williams\" => [\"Adam\", \"Eve\"]\n  \"Brown\"    => [\"Cindy\"]\n  \"Smith\"    => [\"Alice\", \"Bob\", \"Charlie\"]","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"Note that the returned structure is still not a Table at all - it is a dictionary (Dict) with the unique lastname values as keys, returing (non-tabular) arrays of firstname.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"If instead, our grouping elements are rows, the group will be a table. For example, we can just drop the getproperty(:firstname) projection to get:","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> groups = group(getproperty(:lastname), t)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n  \"King\"     => Table with 3 columns and 1 row:…\n  \"Williams\" => Table with 3 columns and 2 rows:…\n  \"Brown\"    => Table with 3 columns and 1 row:…\n  \"Smith\"    => Table with 3 columns and 3 rows:…","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"The results are only summarized (for compactness), but can be easily accessed.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> groups[\"Smith\"]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   ┌─────────────────────────\n 1 │ Alice      Smith     25\n 2 │ Bob        Smith     42\n 3 │ Charlie    Smith     37","category":"page"},{"location":"man/group/#Lazy-grouping","page":"Grouping data","title":"Lazy grouping","text":"","category":"section"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"There are additional functions provided to do grouping while copying less data.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"A groupinds function let's you identify the indices of the rows belonging to certain groups.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> lastname_inds = groupinds(t.lastname)\nDict{String,Array{Int64,1}} with 4 entries:\n  \"King\"     => [7]\n  \"Williams\" => [4, 5]\n  \"Brown\"    => [6]\n  \"Smith\"    => [1, 2, 3]","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"We can then use these indices to perform calculations on each group of data, for example the mean age per lastname grouping.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> using Statistics\n\njulia> Dict(lastname => mean(t.age[inds]) for (lastname, inds) in lastname_inds)\nDict{String,Float64} with 4 entries:\n  \"King\"     => 54.0\n  \"Williams\" => 41.5\n  \"Brown\"    => 33.0\n  \"Smith\"    => 34.6667","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"There is additionally a groupview function, which calculates the groupinds and constructs each subset as a view.","category":"page"},{"location":"man/group/#Summarizing-groups-with-groupreduce","page":"Grouping data","title":"Summarizing groups with groupreduce","text":"","category":"section"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"Sometimes we can perform a split-apply-combine strategy by streaming just once over the data, and reducing over the groups. The groupreduce function lets us do this, and can be more performant than alternative approaches.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"For example, we can sum up the ages corresponding to each family name.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> groupreduce(getproperty(:lastname), getproperty(:age), +, t)\nDict{String,Int64} with 4 entries:\n  \"King\"     => 54\n  \"Williams\" => 83\n  \"Brown\"    => 33\n  \"Smith\"    => 104","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"SplitApplyCombine provides related functions groupsum, groupprod, and so-on. One particularly handy function for summarizing data by giving counts of unique values is groupcount.","category":"page"},{"location":"man/group/","page":"Grouping data","title":"Grouping data","text":"julia> groupcount(t.lastname)\nDict{String,Int64} with 4 entries:\n  \"King\"     => 1\n  \"Williams\" => 2\n  \"Brown\"    => 1\n  \"Smith\"    => 3","category":"page"},{"location":"man/io/#Input-and-output","page":"Input and output","title":"Input and output","text":"","category":"section"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Input and output of Table and FlexTable are mostly handled through externally-defined interfaces.","category":"page"},{"location":"man/io/#AbstractArray-interface","page":"Input and output","title":"AbstractArray interface","text":"","category":"section"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"One can convert an AbstractArray of NamedTuples to a Table using a simple constructor.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> v = [(name=\"Alice\", age=25), (name=\"Bob\", age=42), (name= \"Charlie\", age=37)]\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name = \"Alice\", age = 25)  \n (name = \"Bob\", age = 42)    \n (name = \"Charlie\", age = 37)\n\njulia> t = Table(v)\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"In this way, we have converted a row-based storage container to a column-based storage container.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"One can convert back to row-based storage by collecting the results in an Array. ","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> collect(t)\n3-element Array{NamedTuple{(:name, :age),Tuple{String,Int64}},1}:\n (name = \"Alice\", age = 25)  \n (name = \"Bob\", age = 42)    \n (name = \"Charlie\", age = 37)","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Note that collect is the generic construtor for an Array which accepts any kind of iterable - an \"iterable\" being any type that supports the iterate function.","category":"page"},{"location":"man/io/#*Tables.jl*","page":"Input and output","title":"Tables.jl","text":"","category":"section"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"NOTE: The information in this section represents the development versions of Tables, CSV and related packages.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"The Tables.jl package provides a flexible interface for dealing with tabular data of all forms: from in-memory Tables to CSV files on a disk.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"At it's core, it provides a way of:","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Introspecting data via Tables.istable, Tables.schema, and so-on.\nProvide a row iterator via rows(data), where each row has fields/cells accessed by getproperty.\nProvide a collection of columns via columns(data) that can be accessed via getpropery, each of which iterates fields/cells.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"It's simple design allows us to treat many forms of tabular data in the same way.","category":"page"},{"location":"man/io/#*CSV.jl*","page":"Input and output","title":"CSV.jl","text":"","category":"section"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"As an example of good use of the Tables.jl, take the package CSV.jl, which is designed to load and save CSV files.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Let's say we have a CSV file called input.csv, and the following data.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"name,age\nAlice,25\nBob,42\nCharlie,37","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"We can load this file from disk using the CSV.File constructor.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> using TypedTables, CSV\n\njulia> csvfile = CSV.File(\"input.csv\")\nCSV.File(\"/home/ferris/example.csv\", rows=3):\nTables.Schema:\n :name  Union{Missing, String}\n :age   Union{Missing, Int64}","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Note that CSV has inferred the column types from the data, but by default allows for missing data. This can be controlled via the allowmissing keyword argument (as either :all, :none or :auto).","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> CSV.File(\"input.csv\", allowmissing=:none)\nCSV.File(\"/home/ferris/example.csv\", rows=3):\nTables.Schema:\n :name  String\n :age   Int64 ","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Either of these can finally be converted to a Table.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> Table(csvfile)\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"Similarly, the CSV.jl package supports writing tables with  CSV.write function.","category":"page"},{"location":"man/io/","page":"Input and output","title":"Input and output","text":"julia> CSV.write(\"output.csv\", t)\n\"output.csv\"","category":"page"},{"location":"man/reduce/#Reducing-data","page":"Reducing data","title":"Reducing data","text":"","category":"section"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"Here we demonstrate how to ask a few questions with \"scalar\" answers - like \"Does the table contain x?\", or \"What is the average value of y?\"","category":"page"},{"location":"man/reduce/#Testing-containment","page":"Reducing data","title":"Testing containment","text":"","category":"section"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"One of the most basic questions to ask is: \"Is this element in the table/column?\". Julia's in operator is perfect for this.","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37\n\njulia> in(\"Alice\", t.name)\ntrue\n\njulia> in(\"Debbie\", t.name)\nfalse","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"The in function can also be used as an infix operator, as in \"Alice\" in t.name or \"Alice\" ∈ t.name.","category":"page"},{"location":"man/reduce/#\"How-many?\"","page":"Reducing data","title":"\"How many?\"","text":"","category":"section"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"The count method is useful for asking how many rows satisfy a certain criterion.","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"julia> count(row -> row.age > 40, t)\n1","category":"page"},{"location":"man/reduce/#Totals,-averages,-etc.","page":"Reducing data","title":"Totals, averages, etc.","text":"","category":"section"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"Individual columns can be reduced in the typical way for Julia arrays. Some examples.","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"julia> sum(t.age)\n104\n\njulia> using Statistics\n\njulia> mean(t.age)\n34.666666666666664\n\njulia> median(t.age)\n37.0\n\njulia> join(t.name, \", \", \" and \")\n\"Alice, Bob and Charlie\"","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"Note that join is a string joining function; see innerjoin (from SplitApplyCombine) for the relational operation.","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"It's just as easy to calculate multi-column statistics by reducing over the entire table.","category":"page"},{"location":"man/reduce/","page":"Reducing data","title":"Reducing data","text":"julia> mapreduce(row -> length(row.name) * row.age, +, t)\n510","category":"page"},{"location":"man/join/#Joining-data","page":"Joining data","title":"Joining data","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"The methods defined so far work on single data sources (tables) at-a-time. Sometimes, we need to join information together from multiple tables.","category":"page"},{"location":"man/join/#Cartesian-product/join-of-tables","page":"Joining data","title":"Cartesian product/join of tables","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Before progressing to the typical \"join\" operations on tables, we'll discuss the Cartesian product (or Cartesian \"join\") between two tables. In SQL, this is called the CROSS JOIN.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Suppose table1 has n rows, and table2 has m rows. We can create a new table that contains n × m rows with the data from table1 and table2. In fact, if the output table3 were an n × m matrix of rows, we could say that the row table3[i, j] contains the combination of table1[i] and table2[j].","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"The easiest way to do this is with the SplitApplyCombine.product. For a quick primer, out = product(f, a, b) returns an array out such that out[i, j] = f(a, b). For example, let's take all combinations of the sums of [1, 2, 3] and [10, 20, 30, 40].","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> product(+, [1, 2, 3], [10, 20, 30, 40])\n3×4 Array{Int64,2}:\n 11  21  31  41\n 12  22  32  42\n 13  23  33  43","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"One can also use tuple to simply collect both sets of data.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> product(tuple, [1, 2, 3], [10, 20, 30, 40])\n3×4 Array{Tuple{Int64,Int64},2}:\n (1, 10)  (1, 20)  (1, 30)  (1, 40)\n (2, 10)  (2, 20)  (2, 30)  (2, 40)\n (3, 10)  (3, 20)  (3, 30)  (3, 40)","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"(Note that tuple is the only option for the similar function Iterators.product). Let's try this with a table. This time, for two tables with distinct column names, we can use the merge function to merge the rows into single NamedTuples - for example, take this list of all pairings of firstnames and lastnames.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> t1 = Table(firstname = [\"Alice\", \"Bob\", \"Charlie\"])\nTable with 1 column and 3 rows:\n     firstname\n   ┌──────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie\n\njulia> t2 = Table(lastname = [\"Smith\", \"Williams\", \"Brown\", \"King\"])\nTable with 1 column and 4 rows:\n     lastname\n   ┌─────────\n 1 │ Smith\n 2 │ Williams\n 3 │ Brown\n 4 │ King\n\njulia> t3 = product(merge, t1, t2)\nTable with 2 columns and 3×4 rows:\n       firstname  lastname\n     ┌────────────────────\n 1,1 │ Alice      Smith\n 2,1 │ Bob        Smith\n 3,1 │ Charlie    Smith\n 1,2 │ Alice      Williams\n 2,2 │ Bob        Williams\n 3,2 │ Charlie    Williams\n 1,3 │ Alice      Brown\n 2,3 │ Bob        Brown\n 3,3 │ Charlie    Brown\n 1,4 │ Alice      King\n 2,4 │ Bob        King\n 3,4 │ Charlie    King\n\njulia> size(t3)\n(3, 4)","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Remember that one must be careful that the column names are indeed distinct when using product(merge, ...) this way.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"This is our first example of a Table which an array of higher than one-dimension - it is an AbstractMatrix. The product of many tables may be a 3- or higher-dimensional array. Note that higher-dimensional tables do not print as a matrix like other higher-dimensional arrays at the REPL, as this would quickly obscure the columns. Instead, the indices are displayed to the left of each row.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Finally, also note that there is a productview function for performing this operation lazily. This may be crucial to remember - the size of the output is the product of the size of the inputs, which grows very quickly even for very reasonably sized input tables. This operation can be very expensive in both time and memory if appropriate care isn't taken.","category":"page"},{"location":"man/join/#Cartesian-product-with-generators","page":"Joining data","title":"Cartesian product with generators","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"One can feed in multiple inputs into a generator, and Julia will automatically take the Cartesian product of all inputs. For example:","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> t3 = Table(merge(row1, row2) for row1 in t1, row2 in t2)\nTable with 2 columns and 12 rows:\n      firstname  lastname\n    ┌────────────────────\n 1  │ Alice      Smith\n 2  │ Bob        Smith\n 3  │ Charlie    Smith\n 4  │ Alice      Williams\n 5  │ Bob        Williams\n 6  │ Charlie    Williams\n 7  │ Alice      Brown\n 8  │ Bob        Brown\n 9  │ Charlie    Brown\n 10 │ Alice      King\n 11 │ Bob        King\n 12 │ Charlie    King","category":"page"},{"location":"man/join/#Relational-\"join\"","page":"Joining data","title":"Relational \"join\"","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"In a nutshell: the relational \"join\" operation is simply the above Cartesian product followed by a filtering operation. Generally, the filtering operation will depend on information coming from both input data sets - for example, that the values in a particular column must match exactly. (Any filtering that depends only on information from one input table can be done more efficiently before the join operation).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"For a simple example, let's look for all pairings of firstnames and lastnames that have an equal number of characters. For efficiency, we combine this with productview.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> filter(row -> length(row.firstname) == length(row.lastname), t3)\nTable with 2 columns and 2 rows:\n     firstname  lastname\n   ┌────────────────────\n 1 │ Alice      Smith\n 2 │ Alice      Brown","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Many might find that this two-step process a rather indirect way of performing a join operation. Below we cover two more standard techniques.","category":"page"},{"location":"man/join/#Using-primary-and-foreign-keys","page":"Joining data","title":"Using primary and foreign keys","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Before launching into innerjoin, it is worth taking a detour to expore a common case where a far simpler operation can perform the requisite join - indexing!","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"In a relation, a \"primary\" key is a column (or multiple columns) with values that uniquely identify the row - no two rows may have the same primary key. Table and FlexTable do not directly support uniqueness in the columns (though the array corresponding to a column could surely enforce uniqueness). However, each row is uniquely identified by it's index, for example t1[1] corresponds to the row (firstname = \"Alice\",).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"In fact, using the array index as the primary key can be the most efficient way of uniquely identifying your data. A second table with related data may indeed have a column containing the indices of relevant rows in the first table. Such columns are generally referred to as being a \"foreign key\" (they uniquely identify data in a \"foreign\" table).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"As an example, let's take a simplistic customers and orders database.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> customers = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], address = [\"12 Beach Street\", \"163 Moon Road\", \"6 George Street\"])\nTable with 2 columns and 3 rows:\n     name     address\n   ┌─────────────────────────\n 1 │ Alice    12 Beach Street\n 2 │ Bob      163 Moon Road\n 3 │ Charlie  6 George Street\n\njulia> orders = Table(customer_id = [2, 2, 3, 3], items = [\"Socks\", \"Tie\", \"Shirt\", \"Underwear\"])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   ┌───────────────────────\n 1 │ 2            Socks\n 2 │ 2            Tie\n 3 │ 3            Shirt\n 4 │ 3            Underwear","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"To get the customer for each order is just a simple indexing operation.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> customers[orders.customer_id]\nTable with 2 columns and 4 rows:\n     name     address\n   ┌─────────────────────────\n 1 │ Bob      163 Moon Road\n 2 │ Bob      163 Moon Road\n 3 │ Charlie  6 George Street\n 4 │ Charlie  6 George Street\n","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"We can denormalize the orders and their customers to a single table by performing a merge on each row (in this case using broadcasting dot-syntax for brevity).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> merge.(customers[orders.customer_id], orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   ┌─────────────────────────────────────────────────\n 1 │ Bob      163 Moon Road    2            Socks\n 2 │ Bob      163 Moon Road    2            Tie\n 3 │ Charlie  6 George Street  3            Shirt\n 4 │ Charlie  6 George Street  3            Underwear\n","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"We can perform these operation lazily for cost O(1) using view and mapview - after which the data can be processed further.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> mapview(merge, view(customers, orders.customer_id), orders)\nTable with 4 columns and 4 rows:\n     name     address          customer_id  items\n   ┌─────────────────────────────────────────────────\n 1 │ Bob      163 Moon Road    2            Socks\n 2 │ Bob      163 Moon Road    2            Tie\n 3 │ Charlie  6 George Street  3            Shirt\n 4 │ Charlie  6 George Street  3            Underwear","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"This is a simple and powerful technique. By normalizing your one-to-many relationships into multiple tables using the array index as primary and foreign keys, you can join your data together quickly and efficiently with (possibly lazy) indexing.","category":"page"},{"location":"man/join/#Inner-join","page":"Joining data","title":"Inner join","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"We now turn out attention to the relational join, implemented via SplitApplyCombine's innerjoin function (note that the join function in Base is a concatenation operation on strings, not a relational operation on tables).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"The innerjoin function is flexible, able to join any iterable data source via any comparing predicate, and perform an arbitrary mapping of the matching results. Using ?, we can view its documentation at the REPL:","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"help?> innerjoin\nsearch: innerjoin\n\n  innerjoin(lkey, rkey, f, comparison, left, right)\n\n  Performs a relational-style join operation between iterables left and right,\n  returning a collection of elements f(l, r) for which comparison(lkey(l), rkey(r))\n  is true where l ∈ left, r ∈ right.\n\n  Example\n  ≡≡≡≡≡≡≡≡≡\n\n  julia> innerjoin(iseven, iseven, tuple, ==, [1,2,3,4], [0,1,2])\n  6-element Array{Tuple{Int64,Int64},1}:\n   (1, 1)\n   (2, 0)\n   (2, 2)\n   (3, 1)\n   (4, 0)\n   (4, 2)","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Let's examine this. Assume the inputs left and right are Tables. We may want to join the tables via a single column each, in which case getproperty(:name) would be suitable for lkey and rkey. In the simplest case, such as a natural join, for f we may want to merge all the columns from both input tables (which is the default for f), and the comparison operator may be equality (it defaults to isequal).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"As an example, we modify our customers table to explicitly include the customer's id, similarly to above.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> customers = Table(id = 1:3, name = [\"Alice\", \"Bob\", \"Charlie\"], address = [\"12 Beach Street\", \"163 Moon Road\", \"6 George Street\"])\nTable with 3 columns and 3 rows:\n     id  name     address\n   ┌─────────────────────────────\n 1 │ 1   Alice    12 Beach Street\n 2 │ 2   Bob      163 Moon Road\n 3 │ 3   Charlie  6 George Street\n\njulia> innerjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   ┌─────────────────────────────────────────────────────\n 1 │ 2   Bob      163 Moon Road    2            Socks\n 2 │ 2   Bob      163 Moon Road    2            Tie\n 3 │ 3   Charlie  6 George Street  3            Shirt\n 4 │ 3   Charlie  6 George Street  3            Underwear","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"The innerjoin function can be used to join any tables based on any conditions. However, by default only the isequal comparison is accelerated via a temporary hash index - all other comparisons will invoke an exhaustive O(n^2) algorithm.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"See the section on Acceleration Indices for methods of (a) attaching secondary acceleration indices to your columns, and (b) using these to accelerate operations using comparisons other than isequal. For example, a SortIndex can be used to accelerate joins on order-related predicates, such as the value in one column being smaller than another column.","category":"page"},{"location":"man/join/#Inner-joins-with-generators","page":"Joining data","title":"Inner joins with generators","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"As a final example, generators provide a convenient syntax for filtering Cartesian products of collections - that is, to perform an inner join!","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> Table(merge(customer, order) for customer in customers, order in orders if customer.id == order.customer_id)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   ┌─────────────────────────────────────────────────────\n 1 │ 2   Bob      163 Moon Road    2            Socks\n 2 │ 2   Bob      163 Moon Road    2            Tie\n 3 │ 3   Charlie  6 George Street  3            Shirt\n 4 │ 3   Charlie  6 George Street  3            Underwear","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"The disadvantage of this technique is that it will perform an exhaustive search by default, costing O(n^2).","category":"page"},{"location":"man/join/#Left-group-join","page":"Joining data","title":"Left-group-join","text":"","category":"section"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Currently SplitApplyCombine and TypedTables do not provide what in SQL is called an LEFT OUTER JOIN (or any of the other OUTER JOIN operations).","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"Such a query can be alternatively modeled as a hybrid group/join operation. SplitApplyCombine provides leftgroupjoin to perform precisely this. This is similar to LINQ's GroupJoin method. Let us investigate this query with the same data as for innerjoin, above.","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"julia> groups = leftgroupjoin(getproperty(:id), getproperty(:customer_id), customers, orders)\nDict{Int64,Table{NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Int64,String,String,Int64,String}},1,NamedTuple{(:id, :name, :address, :customer_id, :items),Tuple{Array{Int64,1},Array{String,1},Array{String,1},Array{Int64,1},Array{String,1}}}}} with 3 entries:\n  2 => Table with 5 columns and 2 rows:…\n  3 => Table with 5 columns and 2 rows:…\n  1 => Table with 5 columns and 0 rows:…\n\njulia> groups[1]\nTable with 5 columns and 0 rows:\n     id  name  address  customer_id  items\n   ┌──────────────────────────────────────\n\njulia> groups[2]\nTable with 5 columns and 2 rows:\n     id  name  address        customer_id  items\n   ┌────────────────────────────────────────────\n 1 │ 2   Bob   163 Moon Road  2            Socks\n 2 │ 2   Bob   163 Moon Road  2            Tie\n\njulia> groups[3]\nTable with 5 columns and 2 rows:\n     id  name     address          customer_id  items\n   ┌─────────────────────────────────────────────────────\n 1 │ 3   Charlie  6 George Street  3            Shirt\n 2 │ 3   Charlie  6 George Street  3            Underwear","category":"page"},{"location":"man/join/","page":"Joining data","title":"Joining data","text":"As you can see - 3 groups were identified, according to the distinct keys in the id column of customers. While the first customer had no associated orders, note that an empty group has nonetheless been created. Much like SQL's LEFT OUTER JOIN command, leftgroupjoin lets us handle the case that no matching data is found. While SQL achieves this by noting there is missing data in the columns associated with the right table, here we use a set of nested containers (dictionaries of tables of rows) to denote the relationship.","category":"page"},{"location":"man/reference/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"TypedTables.jl's API is intentially small, relying on existing interfaces to expose powerful and composable functionality.","category":"page"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"The reference material can be easily accessed at the REPL, by pressing ? and typing in the name of the command.","category":"page"},{"location":"man/reference/#Constructing-tables","page":"API reference","title":"Constructing tables","text":"","category":"section"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"TypedTables.Table\nTypedTables.FlexTable","category":"page"},{"location":"man/reference/#TypedTables.Table","page":"API reference","title":"TypedTables.Table","text":"Table(name1 = array1, ...)\n\nCreate a column-storage-based Table with column names name1, etc, from arrays array1, etc. The input arrays array1, etc, must share the same dimensionality and indices.\n\nTable itself is an AbstractArray whose elements are NamedTuples of the form (name1 = first(array1), ...), etc. Rows of the table are obtained via standard array indexing table[i], and columns via table.name.\n\nTable differs from FlexTable in that the columns are immutable - you may add, remove, rename and replace entire columns of a FlexTable, but not a Table. However, Table can access and iterate rows in local scope with fast, fully type-inferred code while FlexTable will be more efficient with a higher-order interface.\n\n\n\n\n\n","category":"type"},{"location":"man/reference/#TypedTables.FlexTable","page":"API reference","title":"TypedTables.FlexTable","text":"FlexTable(name1 = array1, ...)\n\nCreate a column-storage-based FlexTable with column names name1, etc, from arrays array1, etc. The input arrays array1, etc, must share the same dimensionality and indices.\n\nFlexTable itself is an AbstractArray whose elements are NamedTuples of the form (name1 = first(array1), ...), etc. Rows of the table are obtained via standard array indexing table[i], and columns via table.name.\n\nFlexTable differs from Table in that the columns are mutable - you may add, remove, rename and replace entire columns of a FlexTable, but not a Table. However, Table can access and iterate rows in local scope with fast, fully type-inferred code while FlexTable will be more efficient with a higher-order interface.\n\n\n\n\n\n","category":"type"},{"location":"man/reference/#Reflection","page":"API reference","title":"Reflection","text":"","category":"section"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"TypedTables.columns\nTypedTables.columnnames","category":"page"},{"location":"man/reference/#Tables.columns","page":"API reference","title":"Tables.columns","text":"columns(table::Table)\n\nConvert a Table into a NamedTuple of its columns.\n\n\n\n\n\ncolumns(dataframe::FlexTable)\n\nConvert a FlexTable into a NamedTuple of its columns.\n\n\n\n\n\n","category":"function"},{"location":"man/reference/#TypedTables.columnnames","page":"API reference","title":"TypedTables.columnnames","text":"columnnames(table)\n\nReturn a tuple of the column names of a Table.\n\n\n\n\n\ncolumnnames(table)\n\nReturn a tuple of the column names of a Table.\n\n\n\n\n\n","category":"function"},{"location":"man/reference/#Property-selection","page":"API reference","title":"Property selection","text":"","category":"section"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"TypedTables.getproperties\nTypedTables.deleteproperty\nTypedTables.deleteproperties","category":"page"},{"location":"man/reference/#TypedTables.getproperties","page":"API reference","title":"TypedTables.getproperties","text":"getproperties(object, names::Tuple{Vararg{Symbol}})\n\nExtract a set of properties with the given names from an object, returning a new object with just those properties.\n\nExample\n\nExtract properties a and c from a NamedTuple.\n\njulia> nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia> getproperties(nt, (:a, :c))\n(a = 1, c = false)\n\n\n\n\n\ngetproperties(names::Tuple{Vararg{Symbol}})\n\nReturn a function that extracts a set of properties with the given names from an object, returning a new object with just those properties.\n\nInternally, the names are stored as a type parameter of a GetProperties object for the purpose of constant propagation. You may overload the propertytype function to control the type of the object that is returned, which by default will be a NamedTuple. See also getproperty.\n\nExample\n\nExtract properties a and c from a NamedTuple.\n\njulia> nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia> getproperties((:a, :c))(nt)\n(a = 1, c = false)\n\n\n\n\n\n","category":"function"},{"location":"man/reference/#TypedTables.deleteproperty","page":"API reference","title":"TypedTables.deleteproperty","text":"deleteproperty(object, name::Symbol)\n\nReturn a copy of object with the property with the given name removed.\n\nExample\n\njulia> nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia> deleteproperty(nt, :b)\n(a = 1, c = false)\n\n\n\n\n\n","category":"function"},{"location":"man/reference/#TypedTables.deleteproperties","page":"API reference","title":"TypedTables.deleteproperties","text":"deleteproperties(object, names::Tuple{Vararg{Symbol}})\n\nReturn a copy of object with the property with the given names removed.\n\nExample\n\njulia> nt = (a = 1, b = 2.0, c = false, d = \"abc\")\n(a = 1, b = 2.0, c = false)\n\njulia> deleteproperties(nt, (:b, :d))\n(a = 1, c = false)\n\n\n\n\n\n","category":"function"},{"location":"man/reference/#Convenience-macros","page":"API reference","title":"Convenience macros","text":"","category":"section"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"These macros return functions that can be applied to tables and rows.","category":"page"},{"location":"man/reference/","page":"API reference","title":"API reference","text":"TypedTables.@Compute\nTypedTables.@Select","category":"page"},{"location":"man/reference/#TypedTables.@Compute","page":"API reference","title":"TypedTables.@Compute","text":"@Compute(...)\n\nThe @Compute macro returns a function which performs a calculation on the properties of an object, such as a NamedTuple.\n\nThe input expression is standard Julia code, with $ prepended to property names. For example. if you want to refer to a property named a then use $a in the expression.\n\nExample\n\njulia> nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia> @Compute($a + $b)(nt)\n3.0\n\n\n\n\n\n","category":"macro"},{"location":"man/reference/#TypedTables.@Select","page":"API reference","title":"TypedTables.@Select","text":"@Select(...)\n\nThe @Select macro returns a function which performs an arbitrary transformation of the properties of an object, such as a NamedTuple.\n\nThe input expression is a comma-seperated list of lhs = rhs pairs. The lhs is the name of the new property to calculate. The rhs is  standard Julia code, with` prepended to input property names. For example. if you want to rename an input property `ato be calledb, use@Select(b = a)`.\n\nAs a special case, if a property is to be simply replicated the = rhs part can be dropped, for example @Select(a) is synomous with @Select(a = $a).\n\nExample\n\njulia> nt = (a = 1, b = 2.0, c = false)\n(a = 1, b = 2.0, c = false)\n\njulia> @Select(a, sum_a_b = $a + $b)(nt)\n(a = 1, sum_a_b = 3.0)\n\n\n\n\n\n","category":"macro"},{"location":"man/filter/#Finding-data","page":"Finding data","title":"Finding data","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Frequently, we need to find data (i.e. rows of the table) that matches certain criteria, and there are multiple mechanisms for achieving this in Julia. Here we will briefly review map, findall and filter as options.","category":"page"},{"location":"man/filter/#map(predicate,-table)","page":"Finding data","title":"map(predicate, table)","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Following the previous section, we can identify row satisfying an arbitrary predicate using the map function. Note that \"predicate\" is just a name for function that takes an input and returns either true or false.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37\n\njulia> is_old = map(row -> row.age > 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Finally, we can use \"logical\" (i.e. Boolean) indexing to extract the rows where the predicate is true.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> t[is_old]\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"The map(predicate, table) approach will allocate one Bool for each row in the input table - for a total of length(table) bytes. SplitApplyCombine defines a mapview function to do this lazily.","category":"page"},{"location":"man/filter/#findall(predicate,-table)","page":"Finding data","title":"findall(predicate, table)","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"If we wish to locate the indices of the rows where the predicate returns true, we can use Julia's findall function.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> inds = findall(row -> row.age > 40, t)\n1-element Array{Int64,1}:\n 2\n\njulia> t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"This method may be less resource intensive (result in less memory allocated) if you are expecting a small number of matching rows, returing one Int per result.","category":"page"},{"location":"man/filter/#filter(predicate,-table)","page":"Finding data","title":"filter(predicate, table)","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Finally, if we wish to directly filter the table and obtain the rows of interest, we can do that as well.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> filter(row -> row.age > 40, t)\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Internally, the filter method may rely on one of the implementations above.","category":"page"},{"location":"man/filter/#Generators","page":"Finding data","title":"Generators","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Julia's \"generator\" syntax also allows for filtering operations using if.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> Table(row for row in t if row.age > 40)\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42\n","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"This can be combined with mapping at the same time, as in Table(f(row) for row in table if predicate(row)). In Joining Data we discuss how to use generator syntax to combine multiple datasets.","category":"page"},{"location":"man/filter/#Preselection","page":"Finding data","title":"Preselection","text":"","category":"section"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"As mentioned in other sections, it is frequently worthwhile to preselect the columns relating to your search predicate, to avoid any wastage in fetching from memory values in columns that you don't care about.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"One simple example of such a transformation is to first project to the column(s) of interest, followed by using map or findall to identify the indices of the rows where predicate is true, and finally to use getindex or view to obtain the result of the full table.","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"julia> inds = findall(age -> age > 40, t.age)\n1-element Array{Int64,1}:\n 2\n\njulia> t[inds]\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42","category":"page"},{"location":"man/filter/","page":"Finding data","title":"Finding data","text":"Easy, peasy!","category":"page"},{"location":"man/data/#Data-representation","page":"Data representation","title":"Data representation","text":"","category":"section"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"TypedTables leaves the user fully in charge of how they represent and store their data. The only requirements are that each column is an AbstractArray, all the columns have matching sizes, and that each column name is distinct.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"This section contains some basic advice on how to choose what arrays to use to represent your data, depending on your needs.","category":"page"},{"location":"man/data/#Element-types-and-missing-data","page":"Data representation","title":"Element types and missing data","text":"","category":"section"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"Each column is an AbstractArray{T}, where T is the eltype (element type) of the array. Most frequently, this will be a Vector{T}, where Vector is a one-dimensional Array, unless you have special requirements.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"In general, you should try to chose T to be a concrete type, such as Int, Float64, or String. Julia's compiler will know in advance how a concrete type is laid out in memory, and what function methods to dispatch to, allowing it to produce highly optimized machine code similar to hand-written C code.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"Sometimes you may want to have more than one type of data in a column. One very convenient use case for this is to handle missing data. Julia 1.0 contains a value called missing of a type called Missing . Many functions are defined for missing, such as 1 + missing = missing and so-on, so the \"missingness\" of the data propagates correctly through even extremely complex calculations. The union type Union{T, Missing} is the officially recommended way to represent data which may be of type T or otherwise Missing. For example, a column which contains optional Float64 values may be best represent by a Vector{Union{Float64, Missing}}. Union types are treated specially be the compiler, where it takes advantage of the fact that the value can only be of one of a small number of known types.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"If your column may contain any of a variety of Julia types, it may be suitable to use abstract types like Any. You will be able to insert any element into a Vector{Any}, but Julia will have to dynamically deal with the type of each element, slowing down run-time performance. This is a trade-off - using abstract types may allow the programmer to worry less about the details, at the cost of execution speed.","category":"page"},{"location":"man/data/#Array-types","page":"Data representation","title":"Array types","text":"","category":"section"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"As mentioned, each column is an AbstractArray, but there are many different concrete implementations of the AbstractArray interface. The AbstractArray interface can be implemented by any type that has a size and supports random access via getindex - the syntax array[index] - and thus is extremely flexible, yet powerful.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"Array (and Vector) is the prototypical AbstractArray, which provides random access to a flat array of memory. It is the type created by array-literal syntax, such as [1, 2, 3]. You can create an array of a given element type by prepending the type - for example, Float64[1, 2, 3] is equivalent to [1.0, 2.0, 3.0]. You can create an empty vector of a given type T with T[] or the explicit constructor Vector{T}(). If you want to be able to add missing values later, you may want to create an empty array with Union{Float64, Missing}[] or Vector{Union{Float64, Missing}}().","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"Arrays are sufficient for playing with a relatively small amount of data at the REPL. However, TypedTables will let you use any of a wide variety of array types, depending on your needs. A few examples include:","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"Typical Array-based columns represent continugous chunks of memory, and can be memory-mapped from files on disk for a simple way of doing out-of-core analytics.\nAcceleration indices can be attached to columns using the AcceleratedArrays package, speeding up searches and joins.\nSome data can be stored in compressed form using sparse arrays, categorical arrays, and so-on. Ranges such as 1:length(table) are a compact way of including things like the table's primary key/indices as an explicit column.\nColumns could be stored and processed on a GPU with GPU-backed array using CUDA, OpenCL, ArrayFire, etc.\nColumns might be distributed and processed in parallel over multiple machines with DistributedArrays or between multiple processes with SharedArrays.\nIn extreme cases, tables with a small, fixed number of rows might be most efficient represented with a statically sized array.","category":"page"},{"location":"man/data/","page":"Data representation","title":"Data representation","text":"In each case, the user will be able to use much the same interface (and code) to perform their transformations. In the background, Julia's compiler will create specialized, performant machine code, for whichever backing array you choose. You may be able to scale your calculations from rapid experimentation to large-scale production via a few simple changes to your array types.","category":"page"},{"location":"man/tutorial/#Quick-start-tutorial","page":"Quick start tutorial","title":"Quick start tutorial","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"After reading this tutorial, you should be able to use Julia to perform a range of data analysis tasks. Only basic knowledge of Julia is assumed, such as how to install packages and use an array.","category":"page"},{"location":"man/tutorial/#Making-and-using-a-Table","page":"Quick start tutorial","title":"Making and using a Table","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"It's simple to get started and create a table!","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A Table is a wrapper around column arrays. Suppose you have an array containing names and an array containing ages, then you can create a table with two columns:","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A Table behaves as a Julia array that contains named tuples for each row. Each row is a single element - you should consider the above as a one-dimensional container with three elements, rather than as a two-dimensional \"matrix\" of six cells. Another name for a collection of named tuples is a \"relation\", and Tables are useful for performing relational algebra.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"You can access elements (rows) exactly like any other Julia array.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t[1]\n(name = \"Alice\", age = 25)\n\njulia> t[1:2]\nTable with 2 columns and 2 rows:\n     name   age\n   ┌───────────\n 1 │ Alice  25\n 2 │ Bob    42","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A element (row) of the table can be updated with the usual array syntax.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t[1] = (name = \"Alice\", age = 26);  # Alice had a birthday!\n\njulia> t\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    26\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"You can easily access a column by the tables \"properties\", use the . operator.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t.name\n3-element Array{String,1}:\n \"Alice\"  \n \"Bob\"    \n \"Charlie\"","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"You can ask what the properties (column names) of a Table with the propertynames function (as well as the columnnames function).","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> propertynames(t)\n(:name, :age)","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Recall that :name is a Symbol - which you can think of a special kind of string that the compiler works with when considering Julia code itself.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Individual cells can be accessed in two, symmetric ways.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t.name[2]\n\"Bob\"\n\njulia> t[2].name\n\"Bob\"","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Note that the first way is more efficient, and recommended, because in the second case the intermediate value t[2] is assembled from the elements of all the columns. The first syntax also supports updating.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t.name[2] = \"Robert\";  # No nicknames here...\n\njulia> t\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    26\n 2 │ Robert   42\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The names and number of columns in a Table are fixed and immutable. You cannot add, remove, or delete columns from a Table. Instead, a new table should be formed - you can even call the new table by the old variable name, if you want.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Multiple tables and additional columns can be created in the one Table constructor. For example, it is easy to add an additional column.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> Table(t; lastname = [\"Smith\", \"Smith\", \"Smith\"])\nTable with 3 columns and 3 rows:\n     name     age  lastname\n   ┌───────────────────────\n 1 │ Alice    26   Smith\n 2 │ Robert   42   Smith\n 3 │ Charlie  37   Smith","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"And we can delete a column by setting it to nothing.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> Table(t; age = nothing)\nTable with 1 column and 3 rows:\n     name\n   ┌────────\n 1 │ Alice\n 2 │ Robert\n 3 │ Charlie","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Because the names and types of your columns are fixed on any line of code, Julia's compiler is able to produce lightning fast machine code for processing your data.","category":"page"},{"location":"man/tutorial/#FlexTable","page":"Quick start tutorial","title":"FlexTable","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Sometimes, it is handy to be able to add, remove and rename columns without create a new Table container. The FlexTable type allows for this.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> ft = FlexTable(names = [\"Alice\", \"Bob\", \"Charlie\"])\nFlexTable with 1 column and 3 rows:\n     names\n   ┌────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie\n\njulia> ft.age = [25, 42, 37];\n\njulia> ft\nFlexTable with 2 columns and 3 rows:\n     names    age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A column can be deleted by setting it to nothing.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> ft.age = nothing;\n\njulia> ft\nFlexTable with 1 column and 3 rows:\n     names\n   ┌────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A FlexTable will be just as fast as a Table in most contexts. However, Julia's compiler will not be able to predict in advance the names and types of the columns. The main thing to watch is that an explicit for loop over the rows of a FlexTable will be a bit slower than that of a Table - but all the operations demonstrated in this tutorial will be just as speedy!","category":"page"},{"location":"man/tutorial/#Missing-data","page":"Quick start tutorial","title":"Missing data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The recommended way to handle missing data in Julia is by using missing, which is a value with its very own type Missing. For example, we may create a table where some people haven't specified their age.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, missing, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────────\n 1 │ Alice    25\n 2 │ Bob      missing\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"In Julia, missing values propagate safely where this is appropriate. For example, missing + 1 is also missing - if we didn't know the value before, we still don't after adding 1. This makes working with missing data simple and pain-free, and Julia's optimizing compiler also makes it extremely fast.","category":"page"},{"location":"man/tutorial/#Loading-and-saving-data-from-files","page":"Quick start tutorial","title":"Loading and saving data from files","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"TypedTables.jl integrates seemlessly into an ecosystem of Julia I/O packages. For example, we can use CSV.jl to load and save CSV files. Let's say we have a CSV file called input.csv with the following data.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"name,age\nAlice,25\nBob,42\nCharlie,37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"We can load this file from disk using the CSV.read function.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> using CSV\n\njulia> t = CSV.read(\"input.csv\", Table)\nFlexTable with 2 columns and 3 rows:\n     names    age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Similary, we can write a table to a new file output.csv with the CSV.write function.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> CSV.write(\"output.csv\", t)","category":"page"},{"location":"man/tutorial/#Finding-data","page":"Quick start tutorial","title":"Finding data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Julia's broadcasting and indexing syntax can work together to make it easy to find rows of data based on given creteria. Suppose we wanted to find all the \"old\" people in the  table.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37\n\njulia> t.age .> 40\n3-element BitArray{1}:\n false\n  true\n false","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Bob and Alice might disagree about what \"old\" means, but here we have identified all the people over 40 years of age. Note the difference between the \"scalar\" operator > and the  \"broadcasting\" operator .>.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"We can use \"logical\" indexing to collect the rows for which the above predicate is true.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t[t.age .> 40]\nTable with 2 columns and 1 row:\n     name  age\n   ┌──────────\n 1 │ Bob   42","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Data can also be found with Julia's standard filter and findall functions.","category":"page"},{"location":"man/tutorial/#Summarizing-data","page":"Quick start tutorial","title":"Summarizing data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Julia has a range of standard functions for asking common questions about a set of data.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"For example, we can use the in operator to test if an entry is in a column.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> \"Bob\" in t.name\ntrue","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Or if a given row is in the table.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> (name = \"Bob\", age = 41) in t\nfalse","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"(Bob is older than that).","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"We can sum columns, and with the Statistics standard library, we can find the mean, median, and so-on.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> sum(t.age)\n104\n\njulia> using Statistics\n\njulia> mean(t.age)\n34.666666666666664\n\njulia> median(t.age)\n37.0","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"By these metrics, Bob's age is above average!","category":"page"},{"location":"man/tutorial/#Mapping-data","page":"Quick start tutorial","title":"Mapping data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Functions which map rows to new rows can be used to create new tables. ","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Below, we create an annonymous function which takes a row containing a name and an age, and returns an inital letter and whether the person is old (greater than 40), and use Julia's built-in map function.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> map(row -> (initial = first(row.name), is_old = row.age > 40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   ┌────────────────\n 1 │ A        false\n 2 │ B        true\n 3 │ C        false","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Writing anonymous functions can become laborious when dealing with many rows, so the convenience macros @Select and @Compute are provided to aid in their construction.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The @Select macro returns a function that can map a row to a new row (or a table to a new table) by defining a functional mapping for each output column. The above example can alternatively be written as:","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> map(@Select(initial = first($name), is_old = $age > 40), t)\nTable with 2 columns and 3 rows:\n     initial  is_old\n   ┌────────────────\n 1 │ A        false\n 2 │ B        true\n 3 │ C        false","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"For shorthand, the = ... can be omitted to simply extract a column. For example, we can reorder the columns via","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> @Select(age, name)(t)\nTable with 2 columns and 3 rows:\n     age  name\n   ┌─────────────\n 1 │ 25   Alice\n 2 │ 42   Bob\n 3 │ 37   Charlie","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"(Note that here we \"select\" columns directly, rather than using map to select the fields of each row.)","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The @Compute macro returns a function that maps a row to a value. As for @Select, the input column names are prepended with $, for example:","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> map(@Compute($name), t)\n3-element Array{String,1}:\n \"Alice\"  \n \"Bob\"    \n \"Charlie\"","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Unlike an anonymous function, these two macros create an introspectable function that allows computations to take advantage of columnar storage and advanced features like acceleration indices. You may find calculations may be performed faster with the macros for a wide variety of functions like map, broadcast, filter, findall, reduce, group and innerjoin. For instance, the example above simply extracts the name column from t, without performing an explicit map.","category":"page"},{"location":"man/tutorial/#Grouping-data","page":"Quick start tutorial","title":"Grouping data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Frequently, one wishes to group and process data using a so-called \"split-apply-combine\" methodology. TypedTables is a lightweight package and does not provide this functionality directly - but it has been designed carefully to work optimally with external packages.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"One such package is SplitApplyCombine.jl, which provides common operations for grouping and joining data (if you wish, you may view its documentation here).","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"We will demonstrate grouping data with a slightly more complex dataset.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> t2 = Table(firstname = [\"Alice\", \"Bob\", \"Charlie\", \"Adam\", \"Eve\", \"Cindy\", \"Arthur\"], lastname = [\"Smith\", \"Smith\", \"Smith\", \"Williams\", \"Williams\", \"Brown\", \"King\"], age = [25, 42, 37, 65, 18, 33, 54])\nTable with 3 columns and 7 rows:\n     firstname  lastname  age\n   ┌─────────────────────────\n 1 │ Alice      Smith     25\n 2 │ Bob        Smith     42\n 3 │ Charlie    Smith     37\n 4 │ Adam       Williams  65\n 5 │ Eve        Williams  18\n 6 │ Cindy      Brown     33\n 7 │ Arthur     King      54","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Let us begin with basic usage of the group function from SplitApplyCombine, where we wish to group firstnames by their initial letter.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> using SplitApplyCombine\n\njulia> group(first, t2.firstname)\nDict{Char,Array{String,1}} with 4 entries:\n  'C' => [\"Charlie\", \"Cindy\"]\n  'A' => [\"Alice\", \"Adam\", \"Arthur\"]\n  'E' => [\"Eve\"]\n  'B' => [\"Bob\"]","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The group function returns a dictionary (Dict) where the grouping key is calculated on each row by the function passed as the first argument - in this case first. We can see the firstnames starting with the letter A belong to the same group, and so on.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Sometimes you may want to transform the grouped data - you can do so by passing a second mapping function. For example, we may want to group firstnames by lastname.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> group(@Compute($lastname), $Compute($firstname), t2)\nDict{String,Array{String,1}} with 4 entries:\n  \"King\"     => [\"Arthur\"]\n  \"Williams\" => [\"Adam\", \"Eve\"]\n  \"Brown\"    => [\"Cindy\"]\n  \"Smith\"    => [\"Alice\", \"Bob\", \"Charlie\"]","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Note that the returned structure is still not a Table at all - it is a dictionary with the unique lastname values as keys, returing (non-tabular) arrays of firstname.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"If instead, our group elements are rows (named tuples), each group will itslef be a table. For example, we can keep the entire row by dropping the second function.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> families = group(@Compute($lastname), t2)\nGroups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:\n  \"King\"     => Table with 3 columns and 1 row:…\n  \"Williams\" => Table with 3 columns and 2 rows:…\n  \"Brown\"    => Table with 3 columns and 1 row:…\n  \"Smith\"    => Table with 3 columns and 3 rows:…","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The results are only summarized above (for compactness), but can be easily accessed.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> families[\"Smith\"]\nTable with 3 columns and 3 rows:\n     firstname  lastname  age\n   ┌─────────────────────────\n 1 │ Alice      Smith     25\n 2 │ Bob        Smith     42\n 3 │ Charlie    Smith     37","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"There are also more advanced functions groupreduce, groupinds and groupview, which may help you perform your analysis more succinctly and faster, and are covered in later sections of this manual.","category":"page"},{"location":"man/tutorial/#Joining-data","page":"Quick start tutorial","title":"Joining data","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"A very common relational operation is to join the data from two tables based on certain commonalities, such as the values matching in two columns. SplitApplyCombine.jl provides an innerjoin function for precisely this (please note that join is a Julia operation to concatenate strings).","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Let's suppose we have a small database of customers, and the items they have ordered from an online store.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> customers = Table(id = 1:3, name = [\"Alice\", \"Bob\", \"Charlie\"], address = [\"12 Beach Street\", \"163 Moon Road\", \"6 George Street\"])\nTable with 3 columns and 3 rows:\n     id  name     address\n   ┌─────────────────────────────\n 1 │ 1   Alice    12 Beach Street\n 2 │ 2   Bob      163 Moon Road\n 3 │ 3   Charlie  6 George Street\n\njulia> orders = Table(customer_id = [2, 2, 3, 3], items = [\"Socks\", \"Tie\", \"Shirt\", \"Underwear\"])\nTable with 2 columns and 4 rows:\n     customer_id  items\n   ┌───────────────────────\n 1 │ 2            Socks\n 2 │ 2            Tie\n 3 │ 3            Shirt\n 4 │ 3            Underwear","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Here, these two tables are related by the customer's id. We can join the two tables on this column to determine the address that we need to send the items to. The innerjoin function expects two functions, to describe the joining key of the first table and the joining key of the second table. We will use getproperty to select the columns.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"julia> innerjoin(@Compute($id), @Compute($customer_id), customers, orders)\nTable with 5 columns and 4 rows:\n     id  name     address          customer_id  items\n   ┌─────────────────────────────────────────────────────\n 1 │ 2   Bob      163 Moon Road    2            Socks\n 2 │ 2   Bob      163 Moon Road    2            Tie\n 3 │ 3   Charlie  6 George Street  3            Shirt\n 4 │ 3   Charlie  6 George Street  3            Underwear","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"By default, innerjoin will merge all of the columns. Like group, the innerjoin function can accept an additional function to describe a mapping to desired output (as well as a comparison operation on the keys). The more advanced features of innerjoin and other types of joins are covered in later sections of this manual.","category":"page"},{"location":"man/tutorial/#Progressing-onwards","page":"Quick start tutorial","title":"Progressing onwards","text":"","category":"section"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"Congratulations on completing the introductory tutorial. You should now know enough basics to get started with data analysis in Julia using TypedTables.jl and related packages.","category":"page"},{"location":"man/tutorial/","page":"Quick start tutorial","title":"Quick start tutorial","text":"The following setions of the manual demonstrate more advanced techniques, explain the  design of this (and related) packages, and provide an API reference.","category":"page"},{"location":"man/flextable/#FlexTable","page":"FlexTable ","title":"FlexTable","text":"","category":"section"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"This package defines a second tabular container type, FlexTable, that is designed to be a more flexible table.","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"The two primary difference between Table and FlexTable are that","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"The columns can be mutated - that is, we can add, replace or delete a column.\nThe compiler cannot track the types or names of the columns.","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"Thus, a FlexTable provides the same interface as a Table plus some extra operations. However, the fact that the compiler can no longer statically analyse the names and types of the columns at any given moment of the program means that the element type of a FlexTable is no more specific than NamedTuple. Iteration over rows will therefore be slower using for loops than for the equivalent Table - for maximum speed, higher-level functions (like map, filter, reduce, group and innerjoin) or a high-level DSL (like Query.jl) should be utilized.","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"Amongst other things, using FlexTable might allow you to more easily port your code from another environment where the columns are mutable, such as DataFrames.jl.","category":"page"},{"location":"man/flextable/#Adding-or-replacing-columns","page":"FlexTable ","title":"Adding or replacing columns","text":"","category":"section"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"A column can be added by using the . operator (also known as setproperty!).","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"julia> ft = FlexTable(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nFlexTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37\n\njulia> ft.sex = [:F, :M, :M];\n\njulia> ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   ┌──────────────────\n 1 │ Alice    25   F\n 2 │ Bob      42   M\n 3 │ Charlie  37   M","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"The same syntax is used to replace a column.","category":"page"},{"location":"man/flextable/","page":"FlexTable ","title":"FlexTable ","text":"julia> ft.sex = [\"female\", \"male\", \"male\"];\n\njulia> ft\nFlexTable with 3 columns and 3 rows:\n     name     age  sex\n   ┌─────────────────────\n 1 │ Alice    25   female\n 2 │ Bob      42   male\n 3 │ Charlie  37   male","category":"page"},{"location":"man/acceleratedarrays/#Acceleration-Indices-with-*AcceleratedArrays*","page":"Acceleration indices","title":"Acceleration Indices with AcceleratedArrays","text":"","category":"section"},{"location":"man/acceleratedarrays/","page":"Acceleration indices","title":"Acceleration indices","text":"Database systems have evolved many performance tricks over the years to achieve efficiency and scalability. In an environment such as a SQL RDBMS, much effort is put into the creation of an efficient \"query planner\" that will essentially construct a small computer program, ultimately made up of nested loops, searching, mapping and filtering operations, to perform a query. However, the second \"magic\" ingredient used by an RDBMS for performance are secondary \"acceleration indices\", which are pre-calculated views of the data. These views help queries find data that match certain conditions - a hash-map index well let us locate a matching entry in O(1), or a sort-based index will let us quickly locate all the cells less than (or more than) a certain value.","category":"page"},{"location":"man/acceleratedarrays/","page":"Acceleration indices","title":"Acceleration indices","text":"For at least some of the kinds of data analytics performed in Julia, it may be possible to expect the programmer to write and execute their own query plan - that is, to understand their data model, to predict the \"statistics\" regarding the size of and other properties of the data, and to come up with their own rough order of operations that may be efficient. Thus, we may not need to implement a complete query planner to make a viable platform for data analytics in Julia - however, we will absolutely need acceleration indices to perform each elementary operation fast. In the worst case, the programmer would have to construct their own hash-maps and sort-indices (and use them in their own hand-written loops) to obtain peak performance.","category":"page"},{"location":"man/acceleratedarrays/","page":"Acceleration indices","title":"Acceleration indices","text":"The AcceleratedArrays package exists to provide a way of attaching secondary acceleration indices to any array in Julia, to speed up operations such as filter, findall, group and innerjoin in a transparent and generic way. These acceleration indices can be attached to arbitrary columns (or indeed, entire Tables). These indices remain silently attached to their parent array until they encounter an operation they can accelerate. The user is free to write generic code to execute their query, and the presence of the acceleration index will only act to speed up the resulting specialized algorithm constructed by Julia's compiler.","category":"page"},{"location":"man/acceleratedarrays/","page":"Acceleration indices","title":"Acceleration indices","text":"This system allows for an extensible set of acceleration indices - such as accelerated spatial lookup using a spatial search tree, or an inverted index for searching for words in text fields. ","category":"page"},{"location":"man/acceleratedarrays/","page":"Acceleration indices","title":"Acceleration indices","text":"Note: by default, the innerjoin operation will construct a hash-based index to perform a join on two unindexed data sources, meaning most basic data operations can be achieved at reasonable speeds.","category":"page"},{"location":"man/table/#Table","page":"Table","title":"Table","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"It's simple to get started and create a table!","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> using TypedTables\n\njulia> t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   ┌───────\n 1 │ 1  2.0\n 2 │ 2  4.0\n 3 │ 3  6.0\n\njulia> t[1]  # Get first row\n(a = 1, b = 2.0)\n\njulia> t.a  # Get column `a`\n3-element Array{Int64,1}:\n 1\n 2\n 3","category":"page"},{"location":"man/table/#What-is-a-Table?","page":"Table","title":"What is a Table?","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"Table is actually a Julia array type, where each element (row) is a NamedTuple. In particular:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Externally. a Table presents itself as an array of named tuples. That is, each row of the table is represented as one of Julia's new NamedTuples, which are easy to use and highly efficient. In subtype notation, Table <: AbstractArray{<:NamedTuple}.\nInternally, a Table stores a (named) tuple of arrays, and is a convenient structure for column-based storage of tabular data.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Thus, manipulating data as a Table is as easy as manipulating arrays and named tuples - which is something Julia was specifically designed to make simple, efficient and fun. ","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Tables (and their columns) may be an AbstractArray of any dimensionality. This lets you take advantage of Julia's powerful array functionality, such as multidimensional broadcasting. Each column must be an array of the same dimensionality and size of the other columns.","category":"page"},{"location":"man/table/#Why-use-a-Table?","page":"Table","title":"Why use a Table?","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"Two words: productivity and speed.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"TypedTables.jl aims to introduce very few concepts, with minimal learning curve to let you manipulate tabular data. The Table type is a simple wrapper over columns and presents the well-known and extremely productive AbstractArray interface. If you are familiar with arrays and named tuples, you should be able to write your data analytics with a Table.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"However, it would be of little use if the data container was inherently slow, or if using the container was subject to traps and pitfalls where performance falls of a cliff if the programmer uses an otherwise-idiomatic pattern. In this case, for loops over the rows of a Table are possible at the speed of hand-written code in a statically compiled language such as C, because the compiler is fully aware of the types of each column. Thus, users can write generic functions using a mixture of hand-written loops, calls to functions such as map, filter, reduce, group and innerjoin, as well as high-level interfaces provided by packages such as Query.jl - and still obtain optimal performance.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Finally, since Table is unoppinionated about the underlying array storage (and acts more as a convenient metaprogramming layer), the arrays represent each column might have rather distinct properties - for example, supporting in-memory, out-of-core and distributed workloads (see the section on Data Representation for more details).","category":"page"},{"location":"man/table/#Creating-Tables","page":"Table","title":"Creating Tables","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"The easiest way to create a table from columns is with keyword arguments, such as","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"The constructor will equally accept a NamedTuple of columns, as Table((name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])) (note the extra brackets).","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Also, one can easily convert the row-storage-based vector of named tuples into columnar storage using the Table constructor:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> Table([(name = \"Alice\", age = 25), (name = \"Bob\", age = 42), (name = \"Charlie\", age = 37)])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37","category":"page"},{"location":"man/table/#Accessing-data-stored-in-Tables","page":"Table","title":"Accessing data stored in Tables","text":"","category":"section"},{"location":"man/table/#Row-access","page":"Table","title":"Row access","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"A single row of a Table is just a NamedTuple, which is easy to access.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t[1]\n(name = \"Alice\", age = 25)","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Multiple rows can be indexed similarly to standard arrays in Julia:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t[2:3]\nTable with 2 columns and 2 rows:\n     name     age\n   ┌─────────────\n 1 │ Bob      42\n 2 │ Charlie  37","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"One can interrogate the length, size or axes of a Table just like any other AbstractArray:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> length(t)\n3\n\njulia> size(t)\n(3,)","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"(Note: the number of columns does not participate in the size.)","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Finally, if the backing arrays support mutation, rows can be mutated with setindex!","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t[3] = (name = Charlie, name = 38)  # Charlie had a birthday\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  38","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Similarly, rows can be added or removed with push!, pop! and so-on.","category":"page"},{"location":"man/table/#Column-access","page":"Table","title":"Column access","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"A single column can be recovered using Julia's new getproperty syntax using the . operator.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t.name\n3-element Array{String,1}:\n \"Alice\"  \n \"Bob\"    \n \"Charlie\"","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Currently, the simplest way to extract more than one column is to construct a brand new table out of the columns (as in table2 = Table(column1 = table1.column1, column2 = table1.column2, ...)).","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"The columns of a Table can be accessed directly as a NamedTuple of arrays using the columns function.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> columns(t)\n(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"There is a columnnames function for getting the names of the columns:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> columnnames(t)\n(:name, :age)","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Note that the column names are Julia Symbols, which are interned strings tracked by the compiler.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Finally, the values contained in entire columns may be updated using .=, such as t.age .= 0 or t.age .= [26, 43, 38]. Note that skipping the . in .=, such as t.age = [26, 43, 38], will produce an error because the references to the column containers are immutable (if you wish to replace the entire container of a column, you may need to use a FlexTable).","category":"page"},{"location":"man/table/#Cell-access","page":"Table","title":"Cell access","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"From the above, we can see two identical ways to get a cell of data:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"julia> t[1].name\n\"Alice\"\n\njulia> t.name[1]\n\"Alice\"","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"While Julia's compiler will elide a lot of unnecessary code, you may find it faster to index individual cells of the table using the second option (to avoid fetching and constructing the entire named tuple of a row as an intermediate step).","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"Similarly, the value of a cell can be updated via setindex!, for example using the syntax t.name[1] = \"Alicia\". Note that the syntax t[1].name = \"Alicia\" will error because you are trying to mutate t[1], which is an immutable copy of the row (completely independent from t).","category":"page"},{"location":"man/table/#Comparison-with-other-packages","page":"Table","title":"Comparison with other packages","text":"","category":"section"},{"location":"man/table/#DataFrame","page":"Table","title":"DataFrame","text":"","category":"section"},{"location":"man/table/","page":"Table","title":"Table","text":"For those with experience using the DataFrames.jl package, this comparison may be useful:","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"The columns stored in a Table are immutable - you cannot add, remove or rename a column. However, it is very cheap to create a new table with different columns, encouraging a functional programming style to deal with your outer data structure. (See also FlexTable for a more flexible alternative). For comparison, this is a similar approach to IndexedTables and JuliaDB, while DataFrames uses an untyped vector of columns.\nThe columns themselves may be mutable. You may modify the data in one-or-more columns, and add or remove rows as necessary. Thus, operations on the data (not the data structure) can follow an imperative form, if desired.\nThe types of the columns are known to the compiler, making direct operations like iteration of the rows of a Table very fast. The programmer is free to write a combination of low-level for loops, use operations like map, filter, reduce, group or innerjoin, or to use a high-level query interface such as Query.jl - all with the high performance you would expect of a statically compiled language.\nConversely, the Julia compiler spends effort tracking the names and types of all the columns of the table. If you have a very large number of columns (many hundreds), Table may not be a suitable data structure (here, DataFrames dynamically sized and typed vector of columns may be more appropriate).\nTables can be an array of any dimensionality.\nUnlike a DataFrame, you cannot access a single cell in a single getindex call (you should first extract a column, and index a cell from that column). Similarly, the number of columns does not participate in the size or length of a Table.","category":"page"},{"location":"man/table/","page":"Table","title":"Table","text":"A good litimus test of whether a statically-compiled Table or a dynamic approach like DataFrames is more appropriate, is to see whether the written code tends to refer to the columns by name, or whether the column names are more dynamic (and, for example, iteration over columns is required).","category":"page"},{"location":"man/map/#Mapping-rows-of-data","page":"Mapping data","title":"Mapping rows of data","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Some operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a Table).","category":"page"},{"location":"man/map/#Using-map","page":"Mapping data","title":"Using map","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"In Julia, the idiomatic way to perform such an operation is with the map function, which takes a function and an input array.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"One very simple example of this is extracting a column, let's say the column called name from a table of people's names and ages.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> t = Table(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nTable with 2 columns and 3 rows:\n     name     age\n   ┌─────────────\n 1 │ Alice    25\n 2 │ Bob      42\n 3 │ Charlie  37\n\njulia> map(row -> row.name, t)\n3-element Array{String,1}:\n \"Alice\"  \n \"Bob\"    \n \"Charlie\"","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"This has returned and standard Julia array, which will be a copy of the array of the name column. We could also do a more complicated calculation.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> is_old = map(row -> row.age > 40, t)\n3-element Array{Bool,1}:\n false\n  true\n false","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Depending on your definition of \"old\", we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"One can also map rows, which are NamedTuples, to new NamedTuples, which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to firstname):","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(row -> (firstname = row.name,), t)\nTable with 1 column and 3 rows:\n     firstname\n   ┌────────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Internally, this is leveraging Julia's similar interface for constructing new arrays: if we are creating something similar to a Table with an element type that is a NamedTuple, we get a new Table. (The columns themselves are also similar to the existing columns, preserving their structure as appropriate). If the output type is not a NamedTuple, the output array is similar to the first column.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Putting this all together, we can create a brand-new table using map to manipulate both columns.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(row -> (name = row.name, is_old = row.age > 40), t)\nTable with 2 columns and 3 rows:\n     name     is_old\n   ┌────────────────\n 1 │ Alice    false\n 2 │ Bob      true\n 3 │ Charlie  false","category":"page"},{"location":"man/map/#Explicit-for-loops","page":"Mapping data","title":"Explicit for loops","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"One can easily use for loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the first character of the elements of the name column.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> function firstletter(t::Table)\n    out = Vector{Char}(undef, length(t))\n\n    for i in 1:length(t)\n        out[i] = first(t.name[i])\n    end\n\n    return out\nend\n\njulia> firstletter(t)\n3-element Array{Char,1}:\n 'A'\n 'B'\n 'C'","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Julia will use the type information it knows about t to create fast, compiled code. (Pro tip: to make the above loop optimal, adding an @inbounds annotation on the same line before the for loop will remove redundant array bounds checking and make the loop execute faster).","category":"page"},{"location":"man/map/#Generators","page":"Mapping data","title":"Generators","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Julia syntax provide for compact syntax for generators and comprehensions to define arrays.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"The syntax [f(x) for x in y] is called a \"comprehension\" and constructs a new Array.\nThe syntax f(x) for x in y is called a Generator and is a lazy, iterable container called Base.Generator.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Tables can be constructed from Geneartors, allowing for some pretty neat syntax.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> Table((name=row.name, isold=row.age>40) for row in t)\nTable with 2 columns and 3 rows:\n     name     isold\n   ┌───────────────\n 1 │ Alice    false\n 2 │ Bob      true\n 3 │ Charlie  false","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Generators and comprehensions also support filtering data and combining multiple datasets, which cover in Finding Data and Joining Data.","category":"page"},{"location":"man/map/#Preselection","page":"Mapping data","title":"Preselection","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Functions like map are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation map(f, t), the map method has very little insight into what f does.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Thus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent map from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.","category":"page"},{"location":"man/map/#getproperty-and-map","page":"Mapping data","title":"getproperty and map","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"When we want to perform more complex tasks, such as group or innerjoin, we may be interested in extracting data from specific columns.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Given a row, a field is extracted with the row.name syntax - which Julia transforms to the function call getproperty(row, :name). This package defines getproperty(:name) as returning a new, single-argument function that takes a row and returns row.name.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Thus, one way of projecting a table down to a single column is to use the getproperty function, like so:","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(getproperty(:name), t)\n3-element Array{String,1}:\n \"Alice\"\n \"Bob\"\n \"Charlie\"","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"While this operation may seem pointless (it's a lot less direct than t.name, after all!), projecting to a single column will be a common operation for more complex tasks such as grouping data and performing relational joins.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"A naive implementation of this would be to iterate the rows and then project down to just the column of interest. For efficiency, functions like map (and group, innerjoin, etc) will know they can first project a Table or FlexTable to just that column, before continuing - making the operations significantly faster.","category":"page"},{"location":"man/map/#getproperties","page":"Mapping data","title":"getproperties","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"If we wish to get more than one column, to subset our data or to create a multi-column group or join key, we can use the getproperties function, which works like getproperty but accepts a tuple of Symbols for the column names. This works well on rows or tables.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> getproperties((a=1, b=2, c=3), (:a, :c))\n(a = 1, c = 3)","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"By specifying just column names you can get the a curried function, as for getproperty. Even with just a single column selected, this function preserves the column names, in contrast to getproperty. For example:","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(getproperties((:name,)), t)\nTable with 2 columns and 3 rows:\n     name\n   ┌────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie","category":"page"},{"location":"man/map/#deleteproperty-and-deleteproperties","page":"Mapping data","title":"deleteproperty and deleteproperties","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Sometimes one just wants to remove one or more columns from a table, which we can do easily enough for rows or tables using deleteproperty and deleteproperties.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> deleteproperty(t, :age)\nTable with 1 column and 3 rows:\n     name\n   ┌────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie\n\njulia> deleteproperties(t, (:age,))\nTable with 1 column and 3 rows:\n     name\n   ┌────────\n 1 │ Alice\n 2 │ Bob\n 3 │ Charlie","category":"page"},{"location":"man/map/#@Compute-macro","page":"Mapping data","title":"@Compute macro","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"To help create arbitrary computations using data from multiple columns, the @Compute convenience macro is provided. Variables starting with $ will be taken as column names.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(@Compute($age > 40), t)\n3-element Vector{Bool}:\n 0\n 1\n 0","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"The macro is able to pass along information about which columns are necessary to perform the operation to map. In the above, only the age column is iterated during the map operation, making this operation cheaper than some of the strategies above. For very wide tables the speedup will be greater still.","category":"page"},{"location":"man/map/#@Select-macro","page":"Mapping data","title":"@Select macro","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"The @Select macro goes one step further, allowing you to assemble multiple columns of data in a single step. Columns can be copied by name, and new columns can be computed.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> map(@Select(name, age, is_old = $age > 40), t)\nTable with 3 columns and 3 rows:\n     name     age  is_old\n   ┌─────────────────────\n 1 │ Alice    25   false\n 2 │ Bob      42   true\n 3 │ Charlie  37   false","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Once again, only the subset of columns required for each computation is iterated over, speeding up processing compared to naively mapping rows.","category":"page"},{"location":"man/map/#Broadcasting","page":"Mapping data","title":"Broadcasting","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"Since tables are just arrays, the broadcast operation is defined and behaves similarly to map.","category":"page"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"julia> f = @Select(name, age, is_old = $age > 40)\n(::TypedTables.Select{(:name, :age, :is_old), Tuple{TypedTables.GetProperty{:name}, TypedTables.GetProperty{:age}, TypedTables.Compute{(:age,), var\"#9#10\"}}}) (generic function with 1 method)\n\njulia> f.(t)\nTable with 3 columns and 3 rows:\n     name     age  is_old\n   ┌─────────────────────\n 1 │ Alice    25   false\n 2 │ Bob      42   true\n 3 │ Charlie  37   false","category":"page"},{"location":"man/map/#Lazy-mapping","page":"Mapping data","title":"Lazy mapping","text":"","category":"section"},{"location":"man/map/","page":"Mapping data","title":"Mapping data","text":"It is also worth mentioning the possibility of lazily mapping the values. Functions such as mapview from SplitApplyCombine can let you construct a \"view\" of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand. It is worth noting that strategies like this may be used internally in more complicated grouping and joining operations.","category":"page"},{"location":"man/dicttable/#DictTable","page":"DictTable ","title":"DictTable","text":"","category":"section"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"DictTable is similar to Table except that instead of being an AbstractArray it is an AbstractDictionary (from Dictionaries.jl).","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"The advantage of this is that rows can be indexed by a semantically-important key. A common case is that the first column of a table is a unique, primary-key column. When you construct a DictTable in with arrays it will assume the first column is the primary key.","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"julia> using TypedTables\n\njulia> t = DictTable(name = [\"Alice\", \"Bob\", \"Charlie\"], age = [25, 42, 37])\nDictTable with 1 column and 3 rows:\n name      age\n ────────┬────\n Alice   │ 25\n Bob     │ 42\n Charlie │ 37","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"As mentioned, rows can be indexed by the value of the primary key.","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"julia> t[\"Alice\"]\n(name = \"Alice\", age = 25)","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"The columns themselves are dictionaries that can be also be indexed by primary key.","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"julia> t.age\n3-element Dictionaries.Dictionary{String, Int64}\n   \"Alice\" │ 25\n     \"Bob\" │ 42\n \"Charlie\" │ 37\n\njulia> t.age[\"Alice\"]\n25","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"With the design of Dictionaries.jl, these dictionaries are able to share Indices so that this has very little overhead (even with many columns).","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"julia> keys(t.age) === t.name\ntrue","category":"page"},{"location":"man/dicttable/","page":"DictTable ","title":"DictTable ","text":"Note that it is not required that the first column is the primary key. The DictTable constructor can accept arbitrary dictionaries as columns (so long as the keys agree).","category":"page"},{"location":"#TypedTables.jl","page":"Home","title":"TypedTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simple, fast, column-based storage for data analysis in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TypedTables.jl provides two column-based storage containers: Table and FlexTable, both of which represent an array of NamedTuples. This package is designed to be lightweight, easy-to-use and fast, and presents a very minimal new interface to learn.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Data manipulation is possible throught the tools built into Julia (such as map, filter, and reduce) and those provide by SplitApplyCombine.jl (like group and innerjoin). You can speed up data analysis tasks with acceleration indices, by using the AcceleratedArrays.jl package. This package is integrated the Tables.jl interface, and therefore the rest of the data ecosystem such as Query.jl. This documentation includes examples on how to integrate with these packages for a complete data analysis workflow.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Start Julia 1.0, and press ] to enter \"package\" mode. Then type:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add TypedTables","category":"page"},{"location":"","page":"Home","title":"Home","text":"That's it!","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a table:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using TypedTables\n\njulia> t = Table(a = [1, 2, 3], b = [2.0, 4.0, 6.0])\nTable with 2 columns and 3 rows:\n     a  b\n   ┌───────\n 1 │ 1  2.0\n 2 │ 2  4.0\n 3 │ 3  6.0","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now you can read the tutorial to find out what to do with it.","category":"page"}]
}
