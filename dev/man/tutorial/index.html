<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quick start tutorial · TypedTables.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TypedTables.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>Quick start tutorial</a><ul class="internal"><li><a class="tocitem" href="#Making-and-using-a-Table"><span>Making and using a <code>Table</code></span></a></li><li><a class="tocitem" href="#FlexTable"><span><code>FlexTable</code></span></a></li><li><a class="tocitem" href="#Missing-data"><span>Missing data</span></a></li><li><a class="tocitem" href="#Loading-and-saving-data-from-files"><span>Loading and saving data from files</span></a></li><li><a class="tocitem" href="#Finding-data"><span>Finding data</span></a></li><li><a class="tocitem" href="#Summarizing-data"><span>Summarizing data</span></a></li><li><a class="tocitem" href="#Mapping-data"><span>Mapping data</span></a></li><li><a class="tocitem" href="#Grouping-data"><span>Grouping data</span></a></li><li><a class="tocitem" href="#Joining-data"><span>Joining data</span></a></li><li><a class="tocitem" href="#Progressing-onwards"><span>Progressing onwards</span></a></li></ul></li><li><span class="tocitem">Table types</span><ul><li><a class="tocitem" href="../table/">Table</a></li><li><a class="tocitem" href="../flextable/">FlexTable </a></li><li><a class="tocitem" href="../dicttable/">DictTable </a></li></ul></li><li><span class="tocitem">Data storage</span><ul><li><a class="tocitem" href="../data/">Data representation</a></li><li><a class="tocitem" href="../io/">Input and output</a></li></ul></li><li><span class="tocitem">Basic data manipulation</span><ul><li><a class="tocitem" href="../map/">Mapping data</a></li><li><a class="tocitem" href="../filter/">Finding data</a></li><li><a class="tocitem" href="../reduce/">Reducing data</a></li></ul></li><li><span class="tocitem">Grouping and joining data</span><ul><li><a class="tocitem" href="../group/">Grouping data</a></li><li><a class="tocitem" href="../join/">Joining data</a></li></ul></li><li><span class="tocitem">Accelerations</span><ul><li><a class="tocitem" href="../acceleratedarrays/">Acceleration indices</a></li></ul></li><li><a class="tocitem" href="../reference/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quick start tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quick start tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/TypedTables.jl/blob/main/docs/src/man/tutorial.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quick-start-tutorial"><a class="docs-heading-anchor" href="#Quick-start-tutorial">Quick start tutorial</a><a id="Quick-start-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start-tutorial" title="Permalink"></a></h1><p>After reading this tutorial, you should be able to use Julia to perform a range of data analysis tasks. Only basic knowledge of Julia is assumed, such as how to install packages and use an array.</p><h2 id="Making-and-using-a-Table"><a class="docs-heading-anchor" href="#Making-and-using-a-Table">Making and using a <code>Table</code></a><a id="Making-and-using-a-Table-1"></a><a class="docs-heading-anchor-permalink" href="#Making-and-using-a-Table" title="Permalink"></a></h2><p>It&#39;s simple to get started and create a table!</p><p>A <code>Table</code> is a wrapper around column arrays. Suppose you have an array containing names and an array containing ages, then you can create a table with two columns:</p><pre><code class="language-julia hljs">julia&gt; t = Table(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, 42, 37])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37</code></pre><p>A <code>Table</code> behaves as a Julia array that contains named tuples for each row. Each row is a single element - you should consider the above as a one-dimensional container with three elements, rather than as a two-dimensional &quot;matrix&quot; of six cells. Another name for a collection of named tuples is a &quot;relation&quot;, and <code>Table</code>s are useful for performing <a href="https://en.wikipedia.org/wiki/Relational_algebra">relational algebra</a>.</p><p>You can access elements (rows) exactly like any other Julia array.</p><pre><code class="language-julia hljs">julia&gt; t[1]
(name = &quot;Alice&quot;, age = 25)

julia&gt; t[1:2]
Table with 2 columns and 2 rows:
     name   age
   ┌───────────
 1 │ Alice  25
 2 │ Bob    42</code></pre><p>A element (row) of the table can be updated with the usual array syntax.</p><pre><code class="language-julia hljs">julia&gt; t[1] = (name = &quot;Alice&quot;, age = 26);  # Alice had a birthday!

julia&gt; t
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    26
 2 │ Bob      42
 3 │ Charlie  37</code></pre><p>You can easily access a column by the tables &quot;properties&quot;, use the <code>.</code> operator.</p><pre><code class="language-julia hljs">julia&gt; t.name
3-element Array{String,1}:
 &quot;Alice&quot;  
 &quot;Bob&quot;    
 &quot;Charlie&quot;</code></pre><p>You can ask what the properties (column names) of a <code>Table</code> with the <code>propertynames</code> function (as well as the <code>columnnames</code> function).</p><pre><code class="language-julia hljs">julia&gt; propertynames(t)
(:name, :age)</code></pre><p>Recall that <code>:name</code> is a <code>Symbol</code> - which you can think of a special kind of string that the compiler works with when considering Julia code itself.</p><p>Individual cells can be accessed in two, symmetric ways.</p><pre><code class="language-julia hljs">julia&gt; t.name[2]
&quot;Bob&quot;

julia&gt; t[2].name
&quot;Bob&quot;</code></pre><p>Note that the first way is more efficient, and recommended, because in the second case the intermediate value <code>t[2]</code> is assembled from the elements of <em>all</em> the columns. The first syntax also supports updating.</p><pre><code class="language-julia hljs">julia&gt; t.name[2] = &quot;Robert&quot;;  # No nicknames here...

julia&gt; t
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    26
 2 │ Robert   42
 3 │ Charlie  37</code></pre><p>The names and number of columns in a <code>Table</code> are fixed and immutable. You cannot add, remove, or delete columns from a <code>Table</code>. Instead, a new table should be formed - you can even call the new table by the old variable name, if you want.</p><p>Multiple tables and additional columns can be created in the one <code>Table</code> constructor. For example, it is easy to add an additional column.</p><pre><code class="language-julia hljs">julia&gt; Table(t; lastname = [&quot;Smith&quot;, &quot;Smith&quot;, &quot;Smith&quot;])
Table with 3 columns and 3 rows:
     name     age  lastname
   ┌───────────────────────
 1 │ Alice    26   Smith
 2 │ Robert   42   Smith
 3 │ Charlie  37   Smith</code></pre><p>And we can delete a column by setting it to <code>nothing</code>.</p><pre><code class="language-julia hljs">julia&gt; Table(t; age = nothing)
Table with 1 column and 3 rows:
     name
   ┌────────
 1 │ Alice
 2 │ Robert
 3 │ Charlie</code></pre><p>Because the names and types of your columns are fixed on any line of code, Julia&#39;s compiler is able to produce lightning fast machine code for processing your data.</p><h2 id="FlexTable"><a class="docs-heading-anchor" href="#FlexTable"><code>FlexTable</code></a><a id="FlexTable-1"></a><a class="docs-heading-anchor-permalink" href="#FlexTable" title="Permalink"></a></h2><p>Sometimes, it <em>is</em> handy to be able to add, remove and rename columns without create a new <code>Table</code> container. The <code>FlexTable</code> type allows for this.</p><pre><code class="language-julia hljs">julia&gt; ft = FlexTable(names = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;])
FlexTable with 1 column and 3 rows:
     names
   ┌────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie

julia&gt; ft.age = [25, 42, 37];

julia&gt; ft
FlexTable with 2 columns and 3 rows:
     names    age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37</code></pre><p>A column can be deleted by setting it to <code>nothing</code>.</p><pre><code class="language-julia hljs">julia&gt; ft.age = nothing;

julia&gt; ft
FlexTable with 1 column and 3 rows:
     names
   ┌────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie</code></pre><p>A <code>FlexTable</code> will be just as fast as a <code>Table</code> in most contexts. However, Julia&#39;s compiler will not be able to predict in advance the names and types of the columns. The main thing to watch is that an explicit <code>for</code> loop over the rows of a <code>FlexTable</code> will be a bit slower than that of a <code>Table</code> - but all the operations demonstrated in this tutorial will be just as speedy!</p><h2 id="Missing-data"><a class="docs-heading-anchor" href="#Missing-data">Missing data</a><a id="Missing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-data" title="Permalink"></a></h2><p>The recommended way to handle missing data in Julia is by using <code>missing</code>, which is a value with its very own type <code>Missing</code>. For example, we may create a table where some people haven&#39;t specified their age.</p><pre><code class="language-julia hljs">julia&gt; Table(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, missing, 37])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────────
 1 │ Alice    25
 2 │ Bob      missing
 3 │ Charlie  37</code></pre><p>In Julia, <code>missing</code> values propagate safely where this is appropriate. For example, <code>missing + 1</code> is also <code>missing</code> - if we didn&#39;t know the value before, we still don&#39;t after adding <code>1</code>. This makes working with missing data simple and pain-free, and Julia&#39;s optimizing compiler also makes it extremely fast.</p><h2 id="Loading-and-saving-data-from-files"><a class="docs-heading-anchor" href="#Loading-and-saving-data-from-files">Loading and saving data from files</a><a id="Loading-and-saving-data-from-files-1"></a><a class="docs-heading-anchor-permalink" href="#Loading-and-saving-data-from-files" title="Permalink"></a></h2><p><em>TypedTables.jl</em> integrates seemlessly into an ecosystem of Julia I/O packages. For example, we can use <em>CSV.jl</em> to load and save CSV files. Let&#39;s say we have a CSV file called <code>input.csv</code> with the following data.</p><pre><code class="nohighlight hljs">name,age
Alice,25
Bob,42
Charlie,37</code></pre><p>We can load this file from disk using the <code>CSV.read</code> function.</p><pre><code class="language-julia hljs">julia&gt; using CSV

julia&gt; t = CSV.read(&quot;input.csv&quot;, Table)
FlexTable with 2 columns and 3 rows:
     names    age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37</code></pre><p>Similary, we can write a table to a new file <code>output.csv</code> with the <code>CSV.write</code> function.</p><pre><code class="language-julia hljs">julia&gt; CSV.write(&quot;output.csv&quot;, t)</code></pre><h2 id="Finding-data"><a class="docs-heading-anchor" href="#Finding-data">Finding data</a><a id="Finding-data-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-data" title="Permalink"></a></h2><p>Julia&#39;s broadcasting and indexing syntax can work together to make it easy to find rows of data based on given creteria. Suppose we wanted to find all the &quot;old&quot; people in the  table.</p><pre><code class="language-julia hljs">julia&gt; t = Table(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, 42, 37])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37

julia&gt; t.age .&gt; 40
3-element BitArray{1}:
 false
  true
 false</code></pre><p>Bob and Alice might disagree about what &quot;old&quot; means, but here we have identified all the people over 40 years of age. Note the difference between the &quot;scalar&quot; operator <code>&gt;</code> and the  &quot;broadcasting&quot; operator <code>.&gt;</code>.</p><p>We can use &quot;logical&quot; indexing to collect the rows for which the above predicate is <code>true</code>.</p><pre><code class="language-julia hljs">julia&gt; t[t.age .&gt; 40]
Table with 2 columns and 1 row:
     name  age
   ┌──────────
 1 │ Bob   42</code></pre><p>Data can also be found with Julia&#39;s standard <code>filter</code> and <code>findall</code> functions.</p><h2 id="Summarizing-data"><a class="docs-heading-anchor" href="#Summarizing-data">Summarizing data</a><a id="Summarizing-data-1"></a><a class="docs-heading-anchor-permalink" href="#Summarizing-data" title="Permalink"></a></h2><p>Julia has a range of standard functions for asking common questions about a set of data.</p><p>For example, we can use the <code>in</code> operator to test if an entry is in a column.</p><pre><code class="language-julia hljs">julia&gt; &quot;Bob&quot; in t.name
true</code></pre><p>Or if a given row is <code>in</code> the table.</p><pre><code class="language-julia hljs">julia&gt; (name = &quot;Bob&quot;, age = 41) in t
false</code></pre><p>(Bob is older than that).</p><p>We can <code>sum</code> columns, and with the <code>Statistics</code> standard library, we can find the <code>mean</code>, <code>median</code>, and so-on.</p><pre><code class="language-julia hljs">julia&gt; sum(t.age)
104

julia&gt; using Statistics

julia&gt; mean(t.age)
34.666666666666664

julia&gt; median(t.age)
37.0</code></pre><p>By these metrics, Bob&#39;s age <em>is</em> above average!</p><h2 id="Mapping-data"><a class="docs-heading-anchor" href="#Mapping-data">Mapping data</a><a id="Mapping-data-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-data" title="Permalink"></a></h2><p>Functions which map rows to new rows can be used to create new tables. </p><p>Below, we create an annonymous function which takes a row containing a name and an age, and returns an inital letter and whether the person is old (greater than 40), and use Julia&#39;s built-in <code>map</code> function.</p><pre><code class="language-julia hljs">julia&gt; map(row -&gt; (initial = first(row.name), is_old = row.age &gt; 40), t)
Table with 2 columns and 3 rows:
     initial  is_old
   ┌────────────────
 1 │ A        false
 2 │ B        true
 3 │ C        false</code></pre><p>Writing anonymous functions can become laborious when dealing with many rows, so the convenience macros <code>@Select</code> and <code>@Compute</code> are provided to aid in their construction.</p><p>The <code>@Select</code> macro returns a function that can map a row to a new row (or a table to a new table) by defining a functional mapping for each output column. The above example can alternatively be written as:</p><pre><code class="language-julia hljs">julia&gt; map(@Select(initial = first($name), is_old = $age &gt; 40), t)
Table with 2 columns and 3 rows:
     initial  is_old
   ┌────────────────
 1 │ A        false
 2 │ B        true
 3 │ C        false</code></pre><p>For shorthand, the <code>= ...</code> can be omitted to simply extract a column. For example, we can reorder the columns via</p><pre><code class="nohighlight hljs">julia&gt; @Select(age, name)(t)
Table with 2 columns and 3 rows:
     age  name
   ┌─────────────
 1 │ 25   Alice
 2 │ 42   Bob
 3 │ 37   Charlie</code></pre><p>(Note that here we &quot;select&quot; columns directly, rather than using <code>map</code> to select the fields of each row.)</p><p>The <code>@Compute</code> macro returns a function that maps a row to a value. As for <code>@Select</code>, the input column names are prepended with <code>$</code>, for example:</p><pre><code class="language-julia hljs">julia&gt; map(@Compute($name), t)
3-element Array{String,1}:
 &quot;Alice&quot;  
 &quot;Bob&quot;    
 &quot;Charlie&quot;</code></pre><p>Unlike an anonymous function, these two macros create an introspectable function that allows computations to take advantage of columnar storage and advanced features like acceleration indices. You may find calculations may be performed faster with the macros for a wide variety of functions like <code>map</code>, <code>broadcast</code>, <code>filter</code>, <code>findall</code>, <code>reduce</code>, <code>group</code> and <code>innerjoin</code>. For instance, the example above simply extracts the <code>name</code> column from <code>t</code>, without performing an explicit map.</p><h2 id="Grouping-data"><a class="docs-heading-anchor" href="#Grouping-data">Grouping data</a><a id="Grouping-data-1"></a><a class="docs-heading-anchor-permalink" href="#Grouping-data" title="Permalink"></a></h2><p>Frequently, one wishes to group and process data using a so-called &quot;split-apply-combine&quot; methodology. <em>TypedTables</em> is a lightweight package and does not provide this functionality directly - but it has been designed carefully to work optimally with external packages.</p><p>One such package is <em>SplitApplyCombine.jl</em>, which provides common operations for grouping and joining data (if you wish, you may view its documentation <a href="https://github.com/JuliaData/SplitApplyCombine.jl">here</a>).</p><p>We will demonstrate grouping data with a slightly more complex dataset.</p><pre><code class="language-julia hljs">julia&gt; t2 = Table(firstname = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;, &quot;Adam&quot;, &quot;Eve&quot;, &quot;Cindy&quot;, &quot;Arthur&quot;], lastname = [&quot;Smith&quot;, &quot;Smith&quot;, &quot;Smith&quot;, &quot;Williams&quot;, &quot;Williams&quot;, &quot;Brown&quot;, &quot;King&quot;], age = [25, 42, 37, 65, 18, 33, 54])
Table with 3 columns and 7 rows:
     firstname  lastname  age
   ┌─────────────────────────
 1 │ Alice      Smith     25
 2 │ Bob        Smith     42
 3 │ Charlie    Smith     37
 4 │ Adam       Williams  65
 5 │ Eve        Williams  18
 6 │ Cindy      Brown     33
 7 │ Arthur     King      54</code></pre><p>Let us begin with basic usage of the <code>group</code> function from <em>SplitApplyCombine</em>, where we wish to group firstnames by their initial letter.</p><pre><code class="language-julia hljs">julia&gt; using SplitApplyCombine

julia&gt; group(first, t2.firstname)
Dict{Char,Array{String,1}} with 4 entries:
  &#39;C&#39; =&gt; [&quot;Charlie&quot;, &quot;Cindy&quot;]
  &#39;A&#39; =&gt; [&quot;Alice&quot;, &quot;Adam&quot;, &quot;Arthur&quot;]
  &#39;E&#39; =&gt; [&quot;Eve&quot;]
  &#39;B&#39; =&gt; [&quot;Bob&quot;]</code></pre><p>The <code>group</code> function returns a dictionary (<code>Dict</code>) where the grouping key is calculated on each row by the function passed as the first argument - in this case <code>first</code>. We can see the firstnames starting with the letter <code>A</code> belong to the same group, and so on.</p><p>Sometimes you may want to transform the grouped data - you can do so by passing a second mapping function. For example, we may want to group firstnames by lastname.</p><pre><code class="language-julia hljs">julia&gt; group(@Compute($lastname), $Compute($firstname), t2)
Dict{String,Array{String,1}} with 4 entries:
  &quot;King&quot;     =&gt; [&quot;Arthur&quot;]
  &quot;Williams&quot; =&gt; [&quot;Adam&quot;, &quot;Eve&quot;]
  &quot;Brown&quot;    =&gt; [&quot;Cindy&quot;]
  &quot;Smith&quot;    =&gt; [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;]</code></pre><p>Note that the returned structure is still not a <code>Table</code> at all - it is a dictionary with the unique <code>lastname</code> values as keys, returing (non-tabular) arrays of <code>firstname</code>.</p><p>If instead, our group elements are rows (named tuples), each group will itslef be a table. For example, we can keep the entire row by dropping the second function.</p><pre><code class="language-julia hljs">julia&gt; families = group(@Compute($lastname), t2)
Groups{String,Any,Table{NamedTuple{(:firstname, :lastname, :age),Tuple{String,String,Int64}},1,NamedTuple{(:firstname, :lastname, :age),Tuple{Array{String,1},Array{String,1},Array{Int64,1}}}},Dict{String,Array{Int64,1}}} with 4 entries:
  &quot;King&quot;     =&gt; Table with 3 columns and 1 row:…
  &quot;Williams&quot; =&gt; Table with 3 columns and 2 rows:…
  &quot;Brown&quot;    =&gt; Table with 3 columns and 1 row:…
  &quot;Smith&quot;    =&gt; Table with 3 columns and 3 rows:…</code></pre><p>The results are only summarized above (for compactness), but can be easily accessed.</p><pre><code class="language-julia hljs">julia&gt; families[&quot;Smith&quot;]
Table with 3 columns and 3 rows:
     firstname  lastname  age
   ┌─────────────────────────
 1 │ Alice      Smith     25
 2 │ Bob        Smith     42
 3 │ Charlie    Smith     37</code></pre><p>There are also more advanced functions <code>groupreduce</code>, <code>groupinds</code> and <code>groupview</code>, which may help you perform your analysis more succinctly and faster, and are covered in later sections of this manual.</p><h2 id="Joining-data"><a class="docs-heading-anchor" href="#Joining-data">Joining data</a><a id="Joining-data-1"></a><a class="docs-heading-anchor-permalink" href="#Joining-data" title="Permalink"></a></h2><p>A very common relational operation is to <em>join</em> the data from two tables based on certain commonalities, such as the values matching in two columns. <em>SplitApplyCombine.jl</em> provides an <code>innerjoin</code> function for precisely this (please note that <code>join</code> is a Julia operation to concatenate strings).</p><p>Let&#39;s suppose we have a small database of customers, and the items they have ordered from an online store.</p><pre><code class="language-julia hljs">julia&gt; customers = Table(id = 1:3, name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], address = [&quot;12 Beach Street&quot;, &quot;163 Moon Road&quot;, &quot;6 George Street&quot;])
Table with 3 columns and 3 rows:
     id  name     address
   ┌─────────────────────────────
 1 │ 1   Alice    12 Beach Street
 2 │ 2   Bob      163 Moon Road
 3 │ 3   Charlie  6 George Street

julia&gt; orders = Table(customer_id = [2, 2, 3, 3], items = [&quot;Socks&quot;, &quot;Tie&quot;, &quot;Shirt&quot;, &quot;Underwear&quot;])
Table with 2 columns and 4 rows:
     customer_id  items
   ┌───────────────────────
 1 │ 2            Socks
 2 │ 2            Tie
 3 │ 3            Shirt
 4 │ 3            Underwear</code></pre><p>Here, these two tables are related by the customer&#39;s <code>id</code>. We can join the two tables on this column to determine the <code>address</code> that we need to send the <code>items</code> to. The <code>innerjoin</code> function expects two functions, to describe the joining key of the first table and the joining key of the second table. We will use <code>getproperty</code> to select the columns.</p><pre><code class="language-julia hljs">julia&gt; innerjoin(@Compute($id), @Compute($customer_id), customers, orders)
Table with 5 columns and 4 rows:
     id  name     address          customer_id  items
   ┌─────────────────────────────────────────────────────
 1 │ 2   Bob      163 Moon Road    2            Socks
 2 │ 2   Bob      163 Moon Road    2            Tie
 3 │ 3   Charlie  6 George Street  3            Shirt
 4 │ 3   Charlie  6 George Street  3            Underwear</code></pre><p>By default, <code>innerjoin</code> will <code>merge</code> all of the columns. Like <code>group</code>, the <code>innerjoin</code> function can accept an additional function to describe a mapping to desired output (as well as a comparison operation on the keys). The more advanced features of <code>innerjoin</code> and other types of joins are covered in later sections of this manual.</p><h2 id="Progressing-onwards"><a class="docs-heading-anchor" href="#Progressing-onwards">Progressing onwards</a><a id="Progressing-onwards-1"></a><a class="docs-heading-anchor-permalink" href="#Progressing-onwards" title="Permalink"></a></h2><p>Congratulations on completing the introductory tutorial. You should now know enough basics to get started with data analysis in Julia using <em>TypedTables.jl</em> and related packages.</p><p>The following setions of the manual demonstrate more advanced techniques, explain the  design of this (and related) packages, and provide an API reference.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../table/">Table »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 July 2023 08:43">Thursday 6 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
