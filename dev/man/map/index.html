<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mapping data · TypedTables.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">TypedTables.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../tutorial/">Quick start tutorial</a></li><li><span class="tocitem">Table types</span><ul><li><a class="tocitem" href="../table/">Table</a></li><li><a class="tocitem" href="../flextable/">FlexTable </a></li><li><a class="tocitem" href="../dicttable/">DictTable </a></li></ul></li><li><span class="tocitem">Data storage</span><ul><li><a class="tocitem" href="../data/">Data representation</a></li><li><a class="tocitem" href="../io/">Input and output</a></li></ul></li><li><span class="tocitem">Basic data manipulation</span><ul><li class="is-active"><a class="tocitem" href>Mapping data</a><ul class="internal"><li><a class="tocitem" href="#Using-map"><span>Using <code>map</code></span></a></li><li><a class="tocitem" href="#Explicit-for-loops"><span>Explicit <code>for</code> loops</span></a></li><li><a class="tocitem" href="#Generators"><span>Generators</span></a></li><li><a class="tocitem" href="#Preselection"><span>Preselection</span></a></li><li><a class="tocitem" href="#getproperty-and-map"><span><code>getproperty</code> and <code>map</code></span></a></li><li><a class="tocitem" href="#getproperties"><span><code>getproperties</code></span></a></li><li><a class="tocitem" href="#@Compute-macro"><span><code>@Compute</code> macro</span></a></li><li><a class="tocitem" href="#@Select-macro"><span><code>@Select</code> macro</span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li><li><a class="tocitem" href="#Lazy-mapping"><span>Lazy mapping</span></a></li></ul></li><li><a class="tocitem" href="../filter/">Finding data</a></li><li><a class="tocitem" href="../reduce/">Reducing data</a></li></ul></li><li><span class="tocitem">Grouping and joining data</span><ul><li><a class="tocitem" href="../group/">Grouping data</a></li><li><a class="tocitem" href="../join/">Joining data</a></li></ul></li><li><span class="tocitem">Accelerations</span><ul><li><a class="tocitem" href="../acceleratedarrays/">Acceleration indices</a></li></ul></li><li><a class="tocitem" href="../reference/">API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Basic data manipulation</a></li><li class="is-active"><a href>Mapping data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mapping data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaData/TypedTables.jl/blob/main/docs/src/man/map.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mapping-rows-of-data"><a class="docs-heading-anchor" href="#Mapping-rows-of-data">Mapping rows of data</a><a id="Mapping-rows-of-data-1"></a><a class="docs-heading-anchor-permalink" href="#Mapping-rows-of-data" title="Permalink"></a></h1><p>Some operations on your data will act by mapping each row of data in a table to a value, or even to new rows (in the case of relational operations). In either case, you are mapping an element of table (which is an array whose elements are rows) to create a new array of computed elements (whose elements may or may not be rows, and thus may or may not be a <code>Table</code>).</p><h2 id="Using-map"><a class="docs-heading-anchor" href="#Using-map">Using <code>map</code></a><a id="Using-map-1"></a><a class="docs-heading-anchor-permalink" href="#Using-map" title="Permalink"></a></h2><p>In Julia, the idiomatic way to perform such an operation is with the <code>map</code> function, which takes a function and an input array.</p><p>One very simple example of this is extracting a column, let&#39;s say the column called <code>name</code> from a table of people&#39;s names and ages.</p><pre><code class="language-julia hljs">julia&gt; t = Table(name = [&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;], age = [25, 42, 37])
Table with 2 columns and 3 rows:
     name     age
   ┌─────────────
 1 │ Alice    25
 2 │ Bob      42
 3 │ Charlie  37

julia&gt; map(row -&gt; row.name, t)
3-element Array{String,1}:
 &quot;Alice&quot;  
 &quot;Bob&quot;    
 &quot;Charlie&quot;</code></pre><p>This has returned and standard Julia array, which will be a <em>copy</em> of the array of the <code>name</code> column. We could also do a more complicated calculation.</p><pre><code class="language-julia hljs">julia&gt; is_old = map(row -&gt; row.age &gt; 40, t)
3-element Array{Bool,1}:
 false
  true
 false</code></pre><p>Depending on your definition of &quot;old&quot;, we have identified two younger people and one older person - though I suspect that Bob may have a different definition of old than Alice does.</p><p>One can also <code>map</code> rows, which are <code>NamedTuple</code>s, to new <code>NamedTuples</code>, which will naturally result in a new tabular structure. Here is an example where we simply copy the names into a new table (but change the column name to <code>firstname</code>):</p><pre><code class="language-julia hljs">julia&gt; map(row -&gt; (firstname = row.name,), t)
Table with 1 column and 3 rows:
     firstname
   ┌────────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie</code></pre><p>Internally, this is leveraging Julia&#39;s <code>similar</code> interface for constructing new arrays: if we are creating something <code>similar</code> to a <code>Table</code> with an element type that is a <code>NamedTuple</code>, we get a new <code>Table</code>. (The columns themselves are also <code>similar</code> to the existing columns, preserving their structure as appropriate). If the output type is not a <code>NamedTuple</code>, the output array is <code>similar</code> to the first column.</p><p>Putting this all together, we can create a brand-new table using <code>map</code> to manipulate both columns.</p><pre><code class="language-julia hljs">julia&gt; map(row -&gt; (name = row.name, is_old = row.age &gt; 40), t)
Table with 2 columns and 3 rows:
     name     is_old
   ┌────────────────
 1 │ Alice    false
 2 │ Bob      true
 3 │ Charlie  false</code></pre><h2 id="Explicit-for-loops"><a class="docs-heading-anchor" href="#Explicit-for-loops">Explicit <code>for</code> loops</a><a id="Explicit-for-loops-1"></a><a class="docs-heading-anchor-permalink" href="#Explicit-for-loops" title="Permalink"></a></h2><p>One can easily use <code>for</code> loops to iterate over your data and perform whatever mapping is required. For example, this loop takes the <code>first</code> character of the elements of the <code>name</code> column.</p><pre><code class="language-julia hljs">julia&gt; function firstletter(t::Table)
    out = Vector{Char}(undef, length(t))

    for i in 1:length(t)
        out[i] = first(t.name[i])
    end

    return out
end

julia&gt; firstletter(t)
3-element Array{Char,1}:
 &#39;A&#39;
 &#39;B&#39;
 &#39;C&#39;</code></pre><p>Julia will use the type information it knows about <code>t</code> to create fast, compiled code. (Pro tip: to make the above loop <em>optimal</em>, adding an <code>@inbounds</code> annotation on the same line before the <code>for</code> loop will remove redundant array bounds checking and make the loop execute faster).</p><h2 id="Generators"><a class="docs-heading-anchor" href="#Generators">Generators</a><a id="Generators-1"></a><a class="docs-heading-anchor-permalink" href="#Generators" title="Permalink"></a></h2><p>Julia syntax provide for compact syntax for generators and comprehensions to define arrays.</p><ul><li>The syntax <code>[f(x) for x in y]</code> is called a &quot;comprehension&quot; and constructs a new <code>Array</code>.</li><li>The syntax <code>f(x) for x in y</code> is called a <code>Generator</code> and is a lazy, iterable container called <code>Base.Generator</code>.</li></ul><p>Tables can be constructed from <code>Geneartor</code>s, allowing for some pretty neat syntax.</p><pre><code class="language-julia hljs">julia&gt; Table((name=row.name, isold=row.age&gt;40) for row in t)
Table with 2 columns and 3 rows:
     name     isold
   ┌───────────────
 1 │ Alice    false
 2 │ Bob      true
 3 │ Charlie  false</code></pre><p>Generators and comprehensions also support filtering data and combining multiple datasets, which cover in <em>Finding Data</em> and <em>Joining Data</em>.</p><h2 id="Preselection"><a class="docs-heading-anchor" href="#Preselection">Preselection</a><a id="Preselection-1"></a><a class="docs-heading-anchor-permalink" href="#Preselection" title="Permalink"></a></h2><p>Functions like <code>map</code> are not necessarily very intelligent about which columns are required and which are not. The reason is simple: given the operation <code>map(f, t)</code>, the <code>map</code> method has very little insight into what <code>f</code> does.</p><p>Thus, in some cases it might improve performance to preselect the columns of interest. For example, extracting a single column, or constructing a new table with a reduced number of columns, may prevent <code>map</code> from loading unused values as it materializes each full row as it iterates, and lead to performance improvements.</p><h2 id="getproperty-and-map"><a class="docs-heading-anchor" href="#getproperty-and-map"><code>getproperty</code> and <code>map</code></a><a id="getproperty-and-map-1"></a><a class="docs-heading-anchor-permalink" href="#getproperty-and-map" title="Permalink"></a></h2><p>When we want to perform more complex tasks, such as <code>group</code> or <code>innerjoin</code>, we may be interested in extracting data from specific columns.</p><p>Given a <code>row</code>, a field is extracted with the <code>row.name</code> syntax - which Julia transforms to the function call <code>getproperty(row, :name)</code>. This package defines <code>getproperty(:name)</code> as returning a new, single-argument <em>function</em> that takes a <code>row</code> and returns <code>row.name</code>.</p><p>Thus, one way of projecting a table down to a single column is to use the <code>getproperty</code> function, like so:</p><pre><code class="nohighlight hljs">julia&gt; map(getproperty(:name), t)
3-element Array{String,1}:
 &quot;Alice&quot;
 &quot;Bob&quot;
 &quot;Charlie&quot;</code></pre><p>While this operation may seem pointless (it&#39;s a lot less direct than <code>t.name</code>, after all!), projecting to a single column will be a common operation for more complex tasks such as grouping data and performing relational joins.</p><p>A naive implementation of this would be to iterate the rows and <em>then</em> project down to just the column of interest. For efficiency, functions like <code>map</code> (and <code>group</code>, <code>innerjoin</code>, etc) will know they can first project a <code>Table</code> or <code>FlexTable</code> to just that column, before continuing - making the operations significantly faster.</p><h2 id="getproperties"><a class="docs-heading-anchor" href="#getproperties"><code>getproperties</code></a><a id="getproperties-1"></a><a class="docs-heading-anchor-permalink" href="#getproperties" title="Permalink"></a></h2><p>If we wish to get more than one column, to subset our data or to create a multi-column group or join key, we can use the <code>getproperties</code> function, which works like <code>getproperty</code> but accepts a tuple of <code>Symbol</code>s for the column names. This works well on rows or tables.</p><pre><code class="nohighlight hljs">julia&gt; getproperties((a=1, b=2, c=3), (:a, :c))
(a = 1, c = 3)</code></pre><p>By specifying just column names you can get the a curried function, as for <code>getproperty</code>. Even with just a single column selected, this function preserves the column names, in contrast to <code>getproperty</code>. For example:</p><pre><code class="nohighlight hljs">julia&gt; map(getproperties((:name,)), t)
Table with 2 columns and 3 rows:
     name
   ┌────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie</code></pre><h3 id="deleteproperty-and-deleteproperties"><a class="docs-heading-anchor" href="#deleteproperty-and-deleteproperties"><code>deleteproperty</code> and <code>deleteproperties</code></a><a id="deleteproperty-and-deleteproperties-1"></a><a class="docs-heading-anchor-permalink" href="#deleteproperty-and-deleteproperties" title="Permalink"></a></h3><p>Sometimes one just wants to remove one or more columns from a table, which we can do easily enough for rows or tables using <code>deleteproperty</code> and <code>deleteproperties</code>.</p><pre><code class="nohighlight hljs">julia&gt; deleteproperty(t, :age)
Table with 1 column and 3 rows:
     name
   ┌────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie

julia&gt; deleteproperties(t, (:age,))
Table with 1 column and 3 rows:
     name
   ┌────────
 1 │ Alice
 2 │ Bob
 3 │ Charlie</code></pre><h2 id="@Compute-macro"><a class="docs-heading-anchor" href="#@Compute-macro"><code>@Compute</code> macro</a><a id="@Compute-macro-1"></a><a class="docs-heading-anchor-permalink" href="#@Compute-macro" title="Permalink"></a></h2><p>To help create arbitrary computations using data from multiple columns, the <code>@Compute</code> convenience macro is provided. Variables starting with <code>$</code> will be taken as column names.</p><pre><code class="nohighlight hljs">julia&gt; map(@Compute($age &gt; 40), t)
3-element Vector{Bool}:
 0
 1
 0</code></pre><p>The macro is able to pass along information about which columns are necessary to perform the operation to <code>map</code>. In the above, only the <code>age</code> column is iterated during the <code>map</code> operation, making this operation cheaper than some of the strategies above. For very wide tables the speedup will be greater still.</p><h2 id="@Select-macro"><a class="docs-heading-anchor" href="#@Select-macro"><code>@Select</code> macro</a><a id="@Select-macro-1"></a><a class="docs-heading-anchor-permalink" href="#@Select-macro" title="Permalink"></a></h2><p>The <code>@Select</code> macro goes one step further, allowing you to assemble multiple columns of data in a single step. Columns can be copied by name, and new columns can be computed.</p><pre><code class="nohighlight hljs">julia&gt; map(@Select(name, age, is_old = $age &gt; 40), t)
Table with 3 columns and 3 rows:
     name     age  is_old
   ┌─────────────────────
 1 │ Alice    25   false
 2 │ Bob      42   true
 3 │ Charlie  37   false</code></pre><p>Once again, only the subset of columns required for each computation is iterated over, speeding up processing compared to naively mapping rows.</p><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>Since tables are just arrays, the broadcast operation is defined and behaves similarly to <code>map</code>.</p><pre><code class="nohighlight hljs">julia&gt; f = @Select(name, age, is_old = $age &gt; 40)
(::TypedTables.Select{(:name, :age, :is_old), Tuple{TypedTables.GetProperty{:name}, TypedTables.GetProperty{:age}, TypedTables.Compute{(:age,), var&quot;#9#10&quot;}}}) (generic function with 1 method)

julia&gt; f.(t)
Table with 3 columns and 3 rows:
     name     age  is_old
   ┌─────────────────────
 1 │ Alice    25   false
 2 │ Bob      42   true
 3 │ Charlie  37   false</code></pre><h2 id="Lazy-mapping"><a class="docs-heading-anchor" href="#Lazy-mapping">Lazy mapping</a><a id="Lazy-mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Lazy-mapping" title="Permalink"></a></h2><p>It is also worth mentioning the possibility of lazily mapping the values. Functions such as <code>mapview</code> from <em>SplitApplyCombine</em> can let you construct a &quot;view&quot; of a new table based on existing data. This way you can avoid using up precious resources, like RAM, yet can still call up data upon demand. It is worth noting that strategies like this may be used internally in more complicated grouping and joining operations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../io/">« Input and output</a><a class="docs-footer-nextpage" href="../filter/">Finding data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 July 2023 08:43">Thursday 6 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
